<!DOCTYPE html>
<html lang="pt">

<!-- INICIO HEAD (Fechar) -->

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Cofre MK All In</title>
	<!-- ESTILOS -->
	<!-- RESET -->
	<style>
		html,
		body,
		div,
		span,
		applet,
		object,
		iframe,
		h1,
		h2,
		h3,
		h4,
		h5,
		h6,
		p,
		blockquote,
		pre,
		a,
		abbr,
		acronym,
		address,
		big,
		cite,
		code,
		del,
		dfn,
		em,
		img,
		ins,
		kbd,
		q,
		s,
		samp,
		small,
		strike,
		strong,
		sub,
		sup,
		tt,
		var,
		b,
		u,
		i,
		center,
		dl,
		dt,
		dd,
		ol,
		ul,
		li,
		fieldset,
		form,
		label,
		legend,
		table,
		caption,
		tbody,
		tfoot,
		thead,
		tr,
		th,
		td,
		article,
		aside,
		canvas,
		details,
		embed,
		figure,
		figcaption,
		footer,
		header,
		hgroup,
		menu,
		nav,
		output,
		ruby,
		section,
		summary,
		time,
		mark,
		audio,
		video {
			margin: 0;
			padding: 0;
			border: 0;
			font-size: 100%;
		}

		/* HTML5 display-role reset for older browsers */
		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block;
		}

		body {
			line-height: 1;
		}

		ol,
		ul {
			list-style: none;
		}

		blockquote,
		q {
			quotes: none;
		}

		blockquote:before,
		blockquote:after,
		q:before,
		q:after {
			content: "";
			content: none;
		}

		table {
			border-collapse: collapse;
			border-spacing: 0;
		}

		*,
		::after,
		::before {
			box-sizing: border-box;
		}
	</style>

	<!-- INICIO MK CSS -->
	<style>
		/* Variáveis de Temas */
		:root {
			--tClaroTexto: #000;
			--tClaroTextoHigh: #333;
			--tClaroFundo: #fff;
			--tClaroFundoForte: #f7f7f7;
			--tClaroFundoHigh: #ddd;
			--MkFaseCorFundo: var(--g5BrancoElevado);
			--MkFaseCorEfeitoPassivo: var(--g5VerdeLima);
			--MkFaseCorFundoIco: var(--g5BrancoElevado);
			--MkFaseCorFundoIcoBack: var(--g5AzulEscuro66);
			--MkFaseCorFundoIcoAtivo: var(--g5VerdeLimaCC);
			--MkFaseCorTexto: var(--g5AzulEscuro);
			--MkFaseCorTextoBack: var(--g5AzulEscuro);
			--MkFaseCorTextoAtivo: var(--g5AzulClaro);
			--MkFaseCorTextoDisabled: var(--g5CinzaEscuro66);
			--MkFaseCorTextoIcoBack: var(--g5BrancoElevado);
			--MkFaseCorTextoIcoAtivo: var(--g5AzulEscuro);
			--MkFaseCorEfeitoTexto: var(--g5AzulClaro33);
			--timerRestante: var(--g5VerdeLima);
			--timerConsumido: var(--g5BrancoSujo);

			--carregadorInterno1: var(--g5BrancoSujoCC);
			--carregadorInterno2: var(--g5AzulClaroCC);
			--carregadorExterno1: var(--g5VerdeLimaCC);
			--carregadorExterno2: var(--g5AzulEscuroCC);
			--zCarregador: 5011;
			--carregadorCentro: var(--g5VerdeLima);

			/* Seletor mkSel*/
			--mkSelArrowSize: 0px;
			--Main1: var(--g5AzulEscuro);
			--Main2: var(--g5VerdeLima);
			--FundoSeletor: transparent;
			--FundoSeletorOpaco: var(--g5AzulClaro99);
			--FundoSeletorDesativado: #777;
			--BordaItens: #000;
			--FundoItensBgEC: #fff;
			--FundoItensBgEG: #0000 8%, var(--FundoItensBgEC) 0 17%, #0000 0 58%;
			--FundoItensBg: linear-gradient(135deg,
					#0000 20.5%,
					var(--FundoItensBgEC) 0 29.5%,
					#0000 0) 0 calc(var(--FundoItensSize) / 4),
				linear-gradient(45deg, var(--FundoItensBgEG)) calc(var(--FundoItensSize) / 2) 0,
				linear-gradient(135deg,
					var(--FundoItensBgEG),
					var(--FundoItensBgEC) 0 67%,
					#0000 0),
				linear-gradient(45deg,
					var(--FundoItensBgEG),
					var(--FundoItensBgEC) 0 67%,
					#0000 0 83%,
					var(--FundoItensBgEC) 0 92%,
					#0000 0),
				#f7f7f7;
			--FundoItensSize: 30px;
			--FundoItensHover: linear-gradient(0.25turn, var(--g5AzulClaro), transparent);
			--FundoItensMarK: linear-gradient(0.25turn,
					var(--g5AzulEscuro99),
					transparent);
			--FundoItensSel: linear-gradient(0.25turn, transparent, var(--g5VerdeLima));
			--FundoItensSelArrow: linear-gradient(0.25turn,
					transparent,
					var(--g5VerdeLima));
			--FlexinhaCor: var(--g5AzulClaro66);
			--CorItensHover: #000;
			--CorSeletor: var(--CorItensHover);
			--CorItens: var(--BordaItens);
			--ArrowSelecionado: "\2714";

			/* PADROES DA BIBLIOTECA */
			--tTexto: var(--tClaroTexto);
			--tTextoHigh: var(--tClaroTextoHigh);
			--tFundo: var(--tClaroFundo);
			--tFundoForte: var(--tClaroFundoForte);
			--tFundoHigh: var(--tClaroFundoHigh);
			--mkEscurecer: #0005;
			--mkEscurecerForte: #000b;
			--corIconeSim: #3c3;
			--corIconeNao: #777;
			--corIconeNaoHover: #fff;
			--sombraForte: #000;
			--ouro: #daa520;
			--timerEncerrando: #ff8888;
			--offline100: #ff4646ff;
			--offline50: #330000cc;
			--serverOffText: #fff;
			/* EFEITOS */
			--efeitoSobe: #00d1c3;
			--efeitoDodge: #fff9;
			--efeitoDifference: #fff9;
			--efeitoVidro: #cfc3;
			--efeitoPulsar: #ff000099;
			--pulsarInput: #ff660099;
			/* TONALIDADES */
			--tonalidadeVerde: #090;
			--tonalidadeVermelho: #900;
			--tonalidadeCinza: #999;
			/* DIMENCOES */
			--timerW: 30px;
			/* ELEVACOES */
			--mkConfirmadorIndex: 1600;
			--mkSelIndex: 2000;
		}

		/* BLOQUEIA SCROLL, Colocar no Body ou onde tiver scroll */
		.mkSemScrollY {
			height: 100%;
			overflow: hidden;
		}

		/* Oculta o item atual ao adicionar a classe nele */
		*.oculto {
			display: none !important;
		}

		/* HIDE */
		.mkSecreto {
			width: 0px !important;
			min-width: 0px !important;
			max-width: 0px !important;
			height: 0px !important;
			min-height: 0px !important;
			max-height: 0px !important;
			border: 0px !important;
			overflow: hidden !important;
			margin: 0px 0px 0px 0px !important;
			opacity: 0% !important;
			z-index: -1 !important;
			padding: 0px !important;
			box-shadow: none !important;
			outline: none !important;
		}

		/* =======================
	MK Seletor
=========================*/

		.mkSelBloco {
			display: flex;
			flex-direction: column;
			align-items: center;
			border: 0px solid transparent;
			outline: 0;
		}

		.mkSelBloco .mkSel {
			width: 100%;
		}

		.mkSelBloco * {
			outline: 0;
			border: 0px;
		}

		.mkSelBloco:has(.mkSel[disabled]) {
			cursor: not-allowed;
		}

		.mkSelBloco:has(.mkSel[disabled]) .mkSelPesquisa {
			pointer-events: none;
			opacity: 0.4;
			--FundoSeletor: var(--FundoSeletorDesativado);
		}

		.mkSelBloco:has(.mkSel.atualizando) .mkSelPesquisa input,
		.mkSelBloco:has(.mkSel.atualizar) .mkSelPesquisa input {
			animation: mkEfeitoBordaGira 0.3s infinite;
			border-radius: 10px;
		}

		/* KEYFRAMES*/
		@keyframes mkEfeitoBordaGira {
			0% {
				border-top: 1px solid var(--Main1);
				border-right: 1px dashed var(--Main2);
				border-bottom: 1px dashed var(--Main2);
				border-left: 1px dashed var(--Main2);
			}

			25% {
				border-top: 1px dashed var(--Main2);
				border-right: 1px solid var(--Main1);
				border-bottom: 1px dashed var(--Main2);
				border-left: 1px dashed var(--Main2);
			}

			50% {
				border-top: 1px dashed var(--Main2);
				border-right: 1px dashed var(--Main2);
				border-bottom: 1px solid var(--Main1);
				border-left: 1px dashed var(--Main2);
			}

			75% {
				border-top: 1px dashed var(--Main2);
				border-right: 1px dashed var(--Main2);
				border-bottom: 1px dashed var(--Main2);
				border-left: 1px solid var(--Main1);
			}

			100% {
				border-top: 1px solid var(--Main1);
				border-right: 1px dashed var(--Main2);
				border-bottom: 1px dashed var(--Main2);
				border-left: 1px dashed var(--Main2);
			}
		}

		.mkSelPesquisa {
			position: relative;
			display: flex;
			/* overflow: hidden; Tirei para ver a flexa de dentro da div de pesquisa */
			text-decoration: none;
			align-items: center;
			border-radius: 5px;
			background-color: var(--FundoSeletor);
			width: calc(100% - (var(--mkSelArrowSize) * 2));
			height: 100%;
		}

		.mkSelInputExibe {
			background-color: transparent;
			width: 100%;
			cursor: pointer;
			padding: 0px 0px 0px 2px;
		}

		/* ARROW EXTERNO*/
		/*.mkSelBloco:has(.mkSel[data-selmoversel="true"]) {
	 background-color: yellow; 
}*/
		.mkSelBloco:has(.mkSel[data-selmoversel="true"]) .mkSelPesquisa {
			width: calc(100% - 50px);
			/* background-color: lightgreen; */
		}

		.mkSelInputExibeArrow {
			position: absolute;
			right: 5px;
			width: 7px !important;
			min-width: 7px !important;
			max-width: 7px !important;
			height: 7px;
			border: 3px solid transparent;
			border-bottom: 3px solid var(--FlexinhaCor);
			border-left: 3px solid var(--FlexinhaCor);
			transform: rotate(-45deg);
			pointer-events: none;
		}

		.mkSelArrowSelLeft {
			position: absolute;
			left: -25px;
			width: var(--mkSelArrowSize);
			height: 100%;
			border: 1px outset;
			border-top-left-radius: 50%;
			border-bottom-left-radius: 50%;
			line-height: 100%;
			border-color: var(--FlexinhaCor);
			color: var(--Main2);
		}

		.mkSelArrowSelRight {
			position: absolute;
			right: -25px;
			width: var(--mkSelArrowSize);
			height: 100%;
			border: 1px outset;
			border-top-right-radius: 50%;
			border-bottom-right-radius: 50%;
			line-height: 100%;
			border-color: var(--FlexinhaCor);
			color: var(--Main2);
			transition: 0.3s;
		}

		.mkSelArrowSelLeft:hover,
		.mkSelArrowSelRight:hover {
			cursor: pointer;
			border: 1px inset;
			border-color: var(--FlexinhaCor);
		}

		.mkSelArrowSelLeft::before {
			content: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 15 11.8'><path d='M14.9,1a6.5,6.5,0,0,1-1.1,4.9,4.7,4.7,0,0,1-1.1,1c-2.9,2.2-4.8.6-6.8,1.2-.2.1-.5.2-.6.5s.6,3.2-.4,3.2S0,8.8,0,5.9,3.9,0,4.9,0,4.5,3,5,3.7a.9.9,0,0,0,.8.3c4-.2,3,.9,6-.1a4.7,4.7,0,0,0,2-1A4.8,4.8,0,0,0,14.9,1Z'/></svg>");
			width: 50%;
		}

		.mkSelArrowSelRight::before {
			content: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 15 11.8'><path d='M.1,10.8A6.5,6.5,0,0,1,1.2,5.9a4.7,4.7,0,0,1,1.1-1c2.9-2.2,4.8-.6,6.8-1.3a.6.6,0,0,0,.6-.4c.5-.8-.6-3.2.4-3.2S15,2.9,15,5.9s-3.9,5.9-4.9,5.9.4-3-.1-3.7a.9.9,0,0,0-.8-.3c-4,.1-3-.9-6,.1a6.1,6.1,0,0,0-2,.9A5.8,5.8,0,0,0,.1,10.8Z'/></svg>");
			width: 50%;
		}

		.mkSelArrowSelLeft:hover::before {
			transform: translateX(-4px) rotate(55deg) scale(1.2) skew(-35deg);
			transition: 1s cubic-bezier(0.1, 0, 0, 1);
		}

		.mkSelArrowSelRight:hover::before {
			transform: translateX(4px) rotate(55deg) scale(1.2) skew(-35deg);
			transition: 1s cubic-bezier(0.1, 0, 0, 1);
		}

		.mkSelBloco:has(input.mkSelInputExibe:focus) .mkSelInputExibeArrow {
			transform: rotate(-225deg);
		}

		.mkSelBloco:has(input.mkSelInputExibe:focus) .mkSelList {
			display: flex;
		}

		.mkSelList {
			display: none;
			flex-direction: column;
			position: absolute;
			z-index: calc(var(--mkSelIndex));
			text-align: left;
			color: var(--CorItens);
			background: var(--FundoItensBg);
			background-size: var(--FundoItensSize) var(--FundoItensSize);
			border: 1px solid var(--BordaItens);
			border-radius: 5px;
			cursor: pointer;
			user-select: none;
			max-height: 300px;
			overflow-y: auto;
			width: max-content;
		}

		.mkSelBloco:has(input.mkSel[data-dev="true"]) .mkSelList {
			display: flex;
		}

		.mkSelItem {
			display: flex;
			position: relative;
			align-items: center;
			border-radius: 6px;
			height: 26px;
			min-height: 26px;
			max-height: 26px;
			overflow: hidden;
			white-space: nowrap;
			text-overflow: ellipsis;
		}

		.mkSelItem span {
			padding: 3px 15px 3px 3px;
		}

		@media (max-width: 768px) {
			.mkSelList {
				width: calc(100% - 70px);
				position: fixed;
				height: calc(100% - 70px);
				/* max-height: calc(100% - 70px);
		min-height: calc(100% - 70px); */
			}

			.mkSelList .mkSelItem {
				height: 40px;
				min-height: 40px;
				max-height: 40px;
			}

			.mkSelList .mkSelItemDeCima,
			.mkSelList .mkSelItemDeBaixo {
				height: 30px;
				min-height: 30px;
				max-height: 30px;
			}

			.mkSelItem span {
				padding-left: 8px;
			}
		}

		.mkSelItem:hover,
		.mkSelItem[data-s="1"]:hover {
			background: var(--FundoItensHover);
		}

		.mkSelItemArrow {
			position: absolute;
			right: 0px;
			pointer-events: none;
			display: flex;
			justify-content: flex-end;
			align-items: center;
			height: 100%;
		}

		.mkSelItem[data-s="1"] {
			color: var(--CorSeletor);
			background: var(--FundoItensSel);
		}

		.mkSelItem[data-s="1"] .mkSelItemArrow::before {
			display: flex;
			align-items: center;
			padding: 0px 4px;
			color: var(--CorSeletor);
			background: var(--FundoItensSelArrow);
			min-height: 100%;
			content: var(--ArrowSelecionado);
		}

		.mkSelItem[data-m="1"] {
			background: var(--FundoItensMarK);
		}

		/* BOTOES DE MOVER PRA CIMA E PRA BAIXO */
		.mkSelItemDeCima {
			position: sticky;
			background-color: var(--FundoSeletorDesativado);
			color: var(--FundoItens);
			text-align: center;
			top: 0px;
			right: 0;
			z-index: calc(var(--mkSelIndex) + 1);
			line-height: initial;
			/* height: 20px;
	min-height: 20px;
	max-height: 20px; */
		}

		.mkSelItemDeCima:hover {
			background-color: var(--Main2);
			cursor: default;
		}

		.mkSelItemDeBaixo {
			position: sticky;
			background-color: var(--FundoSeletorDesativado);
			color: var(--FundoItens);
			text-align: center;
			bottom: 0px;
			right: 0;
			line-height: initial;
			/* height: 20px;
	min-height: 20px;
	max-height: 20px; */
		}

		.mkSelItemDeBaixo:hover {
			background-color: var(--Main2);
			cursor: default;
		}

		/* =======================
	CSS PERSONALIZADO
=========================*/
		/* Formato Botoes */
		button.mkBtn {
			background: var(--tFundo);
			color: var(--tTexto);
			border-width: 1px;
			border-style: outset;
			border-color: var(--tTextoHigh);
			border-radius: 5px;
			padding: 0.2rem 0.6rem;
		}

		button.mkBtn:hover {
			border-style: inset;
			background: var(--tFundoHigh);
			color: var(--tTexto);
			text-shadow: -1px -1px var(--tFundo);
		}

		button.mkBtnInv {
			background: transparent;
			color: var(--tFundo);
			border-width: 1px;
			border-style: outset;
			border-color: var(--tFundo);
			border-radius: 5px;
			padding: 0.2rem 0.6rem;
			width: 35px;
			min-width: 35px;
			max-width: 35px;
			height: 35px;
			min-height: 35px;
			max-height: 35px;
			line-height: 0;
		}

		button.mkBtnInv:hover {
			border-style: inset;
			border-color: var(--tFundo);
			color: var(--tFundo);
			text-shadow: 1px 1px var(--tTexto);
		}

		/* LI e Barra Navegacao */
		.mkAbas {
			display: flex;
			flex-wrap: wrap;
			padding-left: 0;
			margin-bottom: 0;
			list-style: none;
			background-color: transparent;
			padding: 6px;
			margin-bottom: -4px;
		}

		.mkAbas .mkAbaslink {
			user-select: none;
			text-decoration: none;
			border-top-left-radius: 10px;
			border-top-right-radius: 10px;
			border: 1px solid transparent;
			padding: 5px 15px;
			transition: 0.2s ease-in-out;
		}

		.mkAbas .mkAbaslink.active {
			font-weight: bold;
			cursor: default;
			border: 1px solid var(--tFundoHigh);
			box-shadow: -1px -1px 0px 0px var(--tTextoHigh);
			border-bottom-color: transparent;
			background: var(--tFundoForte);
			color: var(--tTexto);
		}

		.mkAbas .mkAbaslink:not(.active):hover {
			border: 1px solid var(--tFundoHigh);
		}

		div[class*="mkAba"] {
			transition: opacity 0.5s linear;
			opacity: 1;
		}

		div[class*="mkAba"].oculto {
			display: flex !important;
			position: absolute;
			visibility: hidden;
			opacity: 0;
			width: 0;
			min-width: 0;
			max-width: 0;
			height: 0;
			min-height: 0;
			max-height: 0;
			margin: 0;
			padding: 0;
		}

		.mkCard {
			display: flex;
			flex-direction: column;
			padding: 0px 0px 0px 0px;
			overflow: auto;
		}

		/* =======================
	LOADING
=========================*/
		.CarregadorMkBlock {
			position: absolute;
			left: 0px;
			top: 0px;
			width: 100%;
			height: 100%;
			min-height: 100%;
			min-width: 100%;
			font-size: 2rem;
			z-index: 5010;
		}

		.CarregadorMkBlock::before {
			content: "";
			position: fixed;
			left: 0px;
			top: 0px;
			z-index: 5001;
			background-color: var(--mkEscurecerForte);
			min-height: 100%;
			min-width: 100%;
			width: 100%;
			height: 100%;
		}

		.CarregadorMkTopoDireito {
			position: absolute;
			right: 3px;
			top: 3px;
			width: 45px;
			min-width: 45px;
			max-width: 45px;
			height: 45px;
			min-height: 45px;
			max-height: 45px;
			z-index: 5012;
			background-color: transparent;
			border: 1px solid transparent;
			color: var(--tFundo);
			border-color: var(--tFundo);
			display: inline-block;
			line-height: 1;
			text-align: center;
			text-decoration: none;
			vertical-align: middle;
			cursor: pointer;
			-webkit-user-select: none;
			-moz-user-select: none;
			user-select: none;
			padding: 0.375rem 0.75rem;
			border-radius: 0.25rem;
			transition: color 0.2s ease-in-out, background-color 0.2s ease-in-out,
				border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
		}

		.CarregadorMkTopoDireito svg {
			width: 100%;
			height: 100%;
		}

		button.CarregadorMkTopoDireito:hover {
			background-color: var(--tFundo);
			color: var(--tTexto);
		}

		.CarregadorMk {
			margin-top: 10px;
			width: 80px;
			height: 80px;
			color: transparent;
			background: transparent;
			border: transparent double 10px;
			border-left-color: var(--carregadorExterno2);
			border-left-style: solid;
			border-right-color: var(--carregadorExterno2);
			border-right-style: solid;
			border-top-color: var(--carregadorExterno1);
			border-bottom-color: var(--carregadorExterno1);
			border-radius: 100%;
			position: absolute;
			left: 50%;
			top: 50%;
			z-index: var(--zCarregador);
			animation: CarregadorMkAni 4000ms linear infinite;
			overflow: hidden;
		}

		.CarregadorMk::before {
			border: transparent solid 10px;
			border-left-color: var(--carregadorInterno1);
			border-right-color: var(--carregadorInterno2);
			content: "";
			top: -10px;
			left: -10px;
			right: 0px;
			bottom: 0px;
			border-radius: 100%;
			position: absolute;
			animation: CarregadorMkAni 2s linear infinite;
		}

		.CarregadorMk:not(.semAfter)::after {
			border: var(--carregadorCentro) inset 3px;
			position: absolute;
			content: "";
			top: 25px;
			left: 25px;
			right: 25px;
			bottom: 25px;
			animation: CarregadorMkAni 200ms linear infinite;
		}

		@keyframes CarregadorMkAni {
			from {
				transform: rotate(0deg);
			}

			to {
				transform: rotate(360deg);
			}
		}

		.CarregadorMkSemScrollY {
			height: 100%;
			overflow: hidden;
		}

		/* =======================
	MK Effect: Input Pendente (Chrome 105+)
=========================*/
		.divInputInput {
			min-height: 33px;
			padding: 1px;
		}

		.divInputInput:has(.iConsultas) .field-validation-error {
			display: none;
		}

		.divInputInput:has(.pending:not(.iConsultas)) {
			position: relative;
			box-sizing: border-box;
			background-clip: padding-box;
			border: 5px solid transparent;
			border-radius: 10px;
			z-index: 2;
			margin: -5px 0px;
		}

		.divInputInput:has(.pending:not(.iConsultas))::before {
			content: "";
			position: absolute;
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
			z-index: -1;
			margin: -5px;
			border-radius: inherit;
			background: var(--ouro);
			animation: pulsarMk 1.5s ease-in-out alternate infinite;
		}

		@keyframes pulsarMk {

			0%,
			100% {
				background: var(--pulsarInput);
			}

			50% {
				background: transparent;
			}
		}

		/* =======================
	MK Effect: Offline
=========================*/
		.offlineBlock {
			position: absolute;
			display: flex;
			flex-wrap: wrap;
			align-content: center;
			justify-content: center;
			bottom: 50%;
			left: 0px;
			width: 100%;
			height: 100px;
			min-height: 100px;
			min-width: 100%;
			font-size: 2rem;
			z-index: 4010;
			color: var(--serverOffText);
			background: var(--offline100);
			animation: pulsarMk2 1.5s ease-in-out alternate infinite;
			box-shadow: 3px 3px 2px 2px #000;
		}

		.offlineBlock button {
			position: absolute;
			right: 5px;
			top: 20px;
			z-index: 4012;
			background-color: transparent;
			border: 1px solid transparent;
			color: var(--serverOffText);
			border-color: var(--serverOffText);
			display: inline-block;
			font-weight: 400;
			line-height: 1.5;
			text-align: center;
			text-decoration: none;
			vertical-align: middle;
			cursor: pointer;
			-webkit-user-select: none;
			-moz-user-select: none;
			user-select: none;
			font-size: 2rem;
			padding: 0.375rem 0.75rem;
			border-radius: 0.25rem;
			transition: color 0.2s ease-in-out, background-color 0.2s ease-in-out,
				border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
		}

		@keyframes pulsarMk2 {

			0%,
			100% {
				background: var(--offline100);
			}

			50% {
				background: var(--offline50);
			}
		}

		/* =======================
	MK Effect: Pulsar Background
=========================*/
		.pulsarFundo {
			animation: pulsarFundo 1s ease-in-out alternate infinite;
		}

		@keyframes pulsarFundo {

			0%,
			100% {
				background: var(--efeitoPulsar);
			}

			50% {
				background: transparent;
			}
		}

		/* =======================
	MK Effect: Vidro
=========================*/
		.iconeVidro {
			margin-left: -20px;
			display: flex;
			z-index: 2;
		}

		.iconeVidro li {
			position: relative;
			list-style: none;
			margin: 5px;
			margin-top: 5px;
		}

		.iconeVidro li a {
			position: relative;
			width: 3.4rem;
			height: 3.4rem;
			font-size: 2rem;
			display: flex;
			justify-content: center;
			align-items: center;
			border-radius: 10px;
			border: 1px inset var(--g5BrancoSujo99);
			text-decoration: none;
			box-shadow: 1px 1px 2px var(--sombraForte);
			backdrop-filter: blur(1.2px);
			transition: 1s;
			overflow: hidden;
		}

		.iconeVidro li a:hover {
			transform: translateY(10px);
		}

		.iconeVidro li a::before {
			content: "";
			position: absolute;
			top: 0;
			left: 0;
			width: 20px;
			height: 100%;
			background: var(--efeitoVidro);
			transform: skewX(45deg) translateX(100px);
			transition: 0.5s;
		}

		.iconeVidro li a:hover::before {
			transform: skewX(45deg) translateX(-150px);
		}

		/* =======================
	MK Effect: DODGE
=========================*/

		.mkEfeitoDodge {
			position: relative;
			overflow: hidden;
		}

		.mkEfeitoDodge:before {
			content: "";
			position: absolute;
			left: -100%;
			top: -66%;
			width: 25%;
			height: 250%;
			border-radius: 50%;
			transform: rotate(45deg);
			background: linear-gradient(to left,
					transparent,
					var(--efeitoDodge) 50%,
					transparent 100%);
			animation: mkEsquerdaParaDireita 10s infinite linear;
			mix-blend-mode: color-dodge;
		}

		@keyframes mkEsquerdaParaDireita {
			90% {
				left: -100%;
			}

			100% {
				left: 200%;
			}
		}

		/* =======================
	MK Effect: DIFFERENCE
=========================*/

		.mkEfeitoDifference {
			position: relative;
			overflow: hidden;
		}

		.mkEfeitoDifference:before {
			content: "";
			position: absolute;
			left: -50%;
			top: -66%;
			width: 25%;
			height: 250%;
			border-radius: 50%;
			transform: rotate(45deg);
			background: linear-gradient(to left,
					transparent,
					transparent 50%,
					var(--efeitoDifference) 75%,
					transparent 100%);
			animation: mkEsquerdaParaDireita 5s infinite linear;
			mix-blend-mode: difference;
		}

		/* =======================
	MK Effect: TIMER
=========================*/
		.timerOut {
			display: flex;
			width: var(--timerW);
			height: var(--timerW);
			font-size: 0.7rem;
			border: 0px;
			border-radius: 50%;
			background: conic-gradient(var(--timerRestante),
					calc(var(--m) - 0.01turn),
					var(--timerRestante),
					calc(var(--m)),
					var(--timerConsumido),
					calc(var(--m) + 0.01turn),
					var(--timerConsumido));
			margin: auto;
			align-items: center;
			justify-content: center;
			position: relative;
			box-shadow: 0px 0px 1px 1px var(--g5CinzaEscuro);
			text-shadow: 0px 0px 1px #fff;
			overflow: hidden;
		}

		.timerOut.red {
			--timerRestante: var(--timerEncerrando);
		}

		/* =======================
	MK Effect: ESCURECE
=========================*/
		.mkEscurece {
			filter: brightness(40%);
		}

		/* =======================
	MK Effect: FLIP
=========================*/

		.flipArea {
			width: 100%;
			height: 100%;
			perspective: 1000px;
		}

		.flipTarget {
			position: relative;
			height: 100%;
			width: 100%;
			transition: all 0.8s;
			transform-style: preserve-3d;
		}

		.flipFront,
		.flipBack {
			position: absolute;
			width: 100%;
			height: 100%;
			backface-visibility: hidden;
		}

		.flipBack {
			transform: rotateY(180deg);
		}

		.flipArea.sTrue .flipTarget {
			animation: flipVai 2s forwards;
		}

		@keyframes flipVai {
			0% {
				transform: rotateY(0deg);
				scale: 1;
			}

			20% {
				scale: 0.6;
				translate: -20% 0px;
			}

			60% {
				translate: 0px 0px;
			}

			75% {
				transform: rotateY(-180deg);
				translate: 0px 0px;
			}

			100% {
				scale: 1;
				transform: rotateY(-180deg);
			}
		}

		.flipArea.sFalse .flipTarget {
			animation: flipVolta 1.5s forwards;
		}

		@keyframes flipVolta {
			0% {
				transform: rotateY(-180deg);
				scale: 1;
			}

			20% {
				scale: 0.6;
				translate: 20% 0px;
			}

			60% {
				translate: 0px 0px;
			}

			75% {
				translate: 0px 0px;
				transform: rotateY(0deg);
			}

			100% {
				scale: 1;
				transform: rotateY(0deg);
			}
		}

		/* =======================
	MK Effect: ESTRELA
=========================*/
		.mkTerremoto {
			animation-name: estrela;
			animation-duration: 0.2s;
			animation-iteration-count: 2;
			animation-timing-function: linear;
		}

		@keyframes estrela {
			0% {
				transform: translate(-1px, 1px);
			}

			20% {
				transform: translate(0px, -1px);
			}

			40% {
				transform: translate(1px, 1px);
			}

			60% {
				transform: translate(-2px, 0px);
			}

			80% {
				transform: translate(2px, 0px);
			}

			100% {
				transform: translate(-1px, 1px);
			}
		}

		/* =======================
	AREA CONFIRMADOR
=========================*/
		.mkConfirmadorBloco {
			position: fixed;
			display: flex;
			flex-wrap: wrap;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			min-height: 100%;
			min-width: 100%;
			font-size: 2rem;
			border: 0px;
			margin: 0px;
			padding: 0px;
			outline: 0px;
			z-index: var(--mkConfirmadorIndex);
			overflow-x: hidden;
			overflow-y: hidden;
			background: var(--mkEscurecer);
			align-items: center;
		}

		.mkConfirmadorFora {
			width: 100%;
			height: 100%;
			min-height: 100%;
			min-width: 100%;
		}

		.mkConfirmadorArea {
			position: fixed;
			width: auto;
			height: auto;
			border: 1px outset var(--tFundoHigh);
			box-shadow: 6px 6px 10px 1px var(--sombraForte);

			border-radius: 5px;
			background: var(--tFundoHigh);
			color: var(--tTextoHigh);
			margin: auto auto;
			overflow-x: hidden;
			overflow-y: auto;
			padding: 2px;
			display: flex;
			flex-direction: column;
			text-align: center;
			animation: mkEfeitoSurgir 0.5s;
			font-size: 1.2rem;
		}

		.mkConfirmadorTitulo {
			display: flex;
			align-items: center;
			font-size: 1.4rem;
			background-color: var(--tClaroTextoHigh);
			color: var(--tFundoHigh);
			border-radius: 5px;
			width: 100%;
			user-select: none;
		}

		.mkConfirmadorTitulo svg {
			margin-left: 5px;
		}

		.mkConfirmadorTitulo span {
			flex: 0 1 100%;
		}

		.mkConfirmadorArea button {
			margin: 5px auto;
		}

		@keyframes mkEfeitoSurgir {
			from {
				transform: scale(0) translate(200%, 200%);
			}

			to {
				transform: scale(1) translate(0%, 0%);
			}
		}

		.mkConfirmadorTexto {
			padding: 5px;
			color: var(--tClaroTexto);
		}

		.mkConfirmadorBotoes {
			column-gap: 1rem;
		}

		/* =======================
	UI ESTILO BOTAO
=========================*/
		.bBotao {
			color: var(--botaoCor);
			background: var(--botaoFundo);
			background: var(--botaoFundo2);
			box-shadow: 2px 2px 4px 0px var(--botaoCor);
			border-width: 1px;
			border-style: outset;
			border-color: var(--botaoFundo);
			border-radius: 15px;
			padding: 7px 30px;
			background-size: auto 200%;
			transition: 0.2s;
			letter-spacing: 1px;
			user-select: none;
			cursor: pointer;
		}

		.bBotao:hover {
			transition: 0.3s;
			border-style: inset;
			color: var(--botaoCorHover);
			background: var(--botaoFHover);
			background-size: auto 200%;
			animation: mkMoveFundoY 0.3s reverse forwards;
			animation-timing-function: cubic-bezier(0.65, 0.05, 0.36, 1);
			box-shadow: 1px 1px 4px 1px var(--botaoCor);
			transform: translate(1px, 1px);
		}

		.bVerde {
			--botaoFundo: var(--tonalidadeVerde);
			--botaoFundo2: linear-gradient(0deg,
					var(--tonalidadeVerde) 0%,
					var(--tonalidadeVerde) 10%,
					#fff 70%,
					#fff 100%);
			--botaoFHover: linear-gradient(0deg,
					var(--tonalidadeVerde) 0%,
					var(--tonalidadeVerde) 10%,
					#fff 70%,
					#fff 100%);
			--botaoCorHover: #fff;
			--botaoCor: #000;
		}

		.bVermelho {
			--botaoFundo: var(--tonalidadeVermelho);
			--botaoFundo2: linear-gradient(0deg,
					var(--tonalidadeVermelho) 0%,
					var(--tonalidadeVermelho) 10%,
					#fff 70%,
					#fff 100%);
			--botaoFHover: linear-gradient(0deg,
					var(--tonalidadeVermelho) 0%,
					var(--tonalidadeVermelho) 10%,
					#fff 70%,
					#fff 100%);
			--botaoCorHover: #fff;
			--botaoCor: #000;
		}

		.bCinza {
			--botaoFundo: var(--tonalidadeCinza);
			--botaoFundo2: linear-gradient(0deg,
					var(--tonalidadeCinza) 0%,
					var(--tonalidadeCinza) 10%,
					#fff 70%,
					#fff 100%);
			--botaoFHover: linear-gradient(0deg,
					var(--tonalidadeCinza) 0%,
					var(--tonalidadeCinza) 10%,
					#fff 70%,
					#fff 100%);
			--botaoCorHover: #fff;
			--botaoCor: #000;
		}

		/* =======================
	AREA MODAL
=========================*/
		.mkModalBloco {
			position: fixed;
			display: flex;
			flex-wrap: wrap;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			min-height: 100%;
			min-width: 100%;
			font-size: 2rem;
			outline: 0;
			z-index: 1060;
			overflow-x: hidden;
			overflow-y: auto;
			background: var(--modalEscurecer);
		}

		.mkModalConteudo {
			width: calc(100% - 5rem);
			height: calc(100vh - 5rem);
			border: 1px outset var(--tFundoHigh);
			box-shadow: -1px -1px 0px 0px var(--tFundo);
			border-radius: 5px;
			background: var(--tFundoHigh);
			margin: auto auto;
			overflow-x: hidden;
			overflow-y: auto;
			font-size: 1rem;
			padding: 1px 2px 0px 1px;
			display: flex;
			flex-direction: column;
		}

		.mkModalTitulo {
			border-radius: 10px;
			margin-right: 2px;
			border: 1px solid var(--tFundo);
			background: transparent;
		}

		/* =======================
	Barra de FASES
=========================*/
		ul.mkUlFase {
			display: flex;
			flex-direction: row;
			width: 100%;
			margin: auto;
			user-select: none;
			list-style: none;
			padding: 15px 0px 0px 0px;
			font-size: 1rem;
			font-weight: normal;
			background: var(--MkFaseCorFundo);
			background: linear-gradient(0deg, transparent 0%, var(--MkFaseCorFundo) 50%);
			border-radius: 5px;
		}

		ul.mkUlFase li {
			background: transparent;
			flex: 1 0 0%;
			text-align: center;
		}

		ul.mkUlFase li div {
			width: 100%;
			padding: 2px;
		}

		/*ICONE*/
		ul.mkUlFase li .mkFaseIco {
			margin: 0px 0px -11px 0px;
		}

		ul.mkUlFase li .mkFaseIco i {
			position: relative;
			top: -16px;
			border-radius: 50%;
			padding: 5px 8px;
			background: var(--MkFaseCorFundoIco);
			box-shadow: 1px 1px 1px var(--MkFaseCorTextoDisabled);
			outline: 1px solid var(--MkFaseCorFundoIcoAtivo);
			outline-offset: -2px;
			transition: 0.5s ease-in;
		}

		ul.mkUlFase li.mkFaseAtivo .mkFaseIco i {
			outline: 1px solid var(--MkFaseCorTextoAtivo);
		}

		ul.mkUlFase li:not(.mkFaseBack):not(.mkFaseAtivo) .mkFaseIco i {
			border: 1px outset var(--MkFaseCorFundoIcoBack);
		}

		/*COR*/
		ul.mkUlFase li a {
			color: var(--MkFaseCorTexto);
		}

		ul.mkUlFase li a:hover * {
			color: var(--MkFaseCorTextoAtivo);
			cursor: pointer;
		}

		ul.mkUlFase li a:hover .mkFaseIco {
			animation: mkEfeitoFase 1000ms ease-in-out infinite alternate;
		}

		ul.mkUlFase li.disabled a {
			color: var(--MkFaseCorTextoDisabled);
		}

		ul.mkUlFase li.mkFaseBack a {
			color: var(--MkFaseCorTextoBack);
		}

		ul.mkUlFase li.mkFaseAtivo a {
			color: var(--MkFaseCorTextoAtivo);
		}

		ul.mkUlFase li.mkFaseBack .mkFaseIco i {
			color: var(--MkFaseCorTextoIcoBack);
			background: var(--MkFaseCorFundoIcoBack);
			text-shadow: 1px 1px var(--MkFaseCorTexto);
		}

		ul.mkUlFase li.mkFaseAtivo .mkFaseIco i {
			color: var(--MkFaseCorTextoIcoAtivo);
			background: var(--MkFaseCorFundoIcoAtivo);
			text-shadow: 1px 1px var(--MkFaseCorTextoIcoBack);
		}

		/*EFEITO*/
		ul.mkUlFase li .mkFaseEfeito {
			padding: 2px 0px 0px 0px;
		}

		ul.mkUlFase li .mkFaseEfeito:nth-child(odd) {
			background: var(--MkFaseCorEfeitoPassivo);
		}

		ul.mkUlFase li.mkFaseBack .mkFaseEfeito {
			background: var(--MkFaseCorTexto);
		}

		ul.mkUlFase li.mkFaseAtivo .mkFaseEfeito {
			background: linear-gradient(90deg,
					var(--MkFaseCorTexto) 20%,
					var(--MkFaseCorEfeitoPassivo) 70%);
		}

		ul.mkUlFase li.mkFaseAtivo .mkFaseEfeito:nth-child(even) {
			background: linear-gradient(90deg,
					var(--MkFaseCorTexto) 20%,
					transparent 70%);
		}

		/* LABEL */
		ul.mkUlFase li label {
			display: block;
			position: relative;
			transition: 0.5s;
		}

		ul.mkUlFase li label::before {
			content: "";
			position: absolute;
			background: var(--MkFaseCorEfeitoTexto);
			left: 10%;
			width: 80%;
			height: 1px;
			top: 100%;
			transition: transform 0.3s linear;
			transform: scaleX(0);
			transform-origin: right;
		}

		ul.mkUlFase li:hover label::before {
			transform: scaleX(1);
			transform-origin: left;
		}

		/* OUTROS */
		ul.mkUlFase a {
			text-decoration: none;
		}

		ul.mkUlFase li.disabled a {
			pointer-events: none;
			cursor: default;
		}

		@keyframes mkEfeitoFase {
			100% {
				filter: drop-shadow(0px 0px 2px var(--MkFaseCorTextoAtivo));
			}
		}

		/* .:ESTRATEGIAS MK CSS:.
	MICRO FLEX POSICOES
1 2 3
4 5 6
7 8 9 */
		.microPos1 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: flex-start;
			align-content: flex-start;
		}

		.microPos2 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: center;
			align-content: flex-start;
		}

		.microPos3 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: flex-end;
			align-content: flex-start;
		}

		.microPos4 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: flex-start;
			align-content: center;
		}

		.microPos5 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: center;
			align-content: center;
			justify-items: center;
			align-items: center;
		}

		.microPos6 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: flex-end;
			align-content: center;
		}

		.microPos7 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: flex-start;
			align-content: flex-end;
		}

		.microPos8 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: center;
			align-content: flex-end;
		}

		.microPos9 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: flex-end;
			align-content: flex-end;
		}

		/* GRID */
		.macroGrid {
			--min: 180px;
			--max: 1fr;
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(var(--min), var(--max)));
		}

		/* ABSOLUTE */
		.absPos1 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			top: 0;
			left: 0;
			justify-content: flex-start;
			align-content: flex-start;
		}

		.absPos2 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			top: 0;
			left: 50%;
			justify-content: center;
			align-content: flex-start;
		}

		.absPos3 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			top: 0;
			right: 0;
			justify-content: flex-end;
			align-content: flex-start;
		}

		.absPos4 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			bottom: 50%;
			left: 0;
			justify-content: flex-start;
			align-content: center;
		}

		.absPos5 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			bottom: 50%;
			left: 50%;
			justify-content: center;
			align-content: center;
		}

		.absPos6 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			bottom: 50%;
			right: 0;
			justify-content: flex-end;
			align-content: center;
		}

		.absPos7 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			bottom: 0;
			left: 0;
			justify-content: flex-start;
			align-content: flex-end;
		}

		.absPos8 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			bottom: 0;
			left: 50%;
			justify-content: center;
			align-content: flex-end;
		}

		.absPos9 {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			position: absolute;
			bottom: 0;
			right: 0;
			justify-content: flex-end;
			align-content: flex-end;
		}

		/* ESTRATEGIAS DE DIMENCIONAMENTO */
		.semGap {
			display: flex;
			grid-column-gap: 0px;
			gap: 0px;
			flex-direction: row;
			flex-wrap: wrap;
			width: 100%;
			margin: 0px 0px 0px 0px;
		}

		.espacoEntre {
			align-content: space-between;
			justify-content: space-between;
		}

		.col7 {
			flex: 1 0 7% !important;
		}

		.col10 {
			flex: 1 0 10% !important;
		}

		.col15 {
			flex: 1 0 15% !important;
		}

		.col20 {
			flex: 1 0 20% !important;
		}

		.col25 {
			flex: 1 1 25% !important;
		}

		.col30 {
			flex: 1 0 30% !important;
		}

		.col33 {
			flex: 1 0 33.33% !important;
		}

		.col37 {
			flex: 1 0 37.5% !important;
		}

		.col40 {
			flex: 1 0 40% !important;
		}

		.col49 {
			flex: 1 0 49% !important;
		}

		.col50 {
			flex: 1 0 50% !important;
		}

		.col60 {
			flex: 1 0 60% !important;
		}

		.col66 {
			flex: 1 0 66.66% !important;
		}

		.col70 {
			flex: 1 0 70% !important;
		}

		.col75 {
			flex: 1 0 75% !important;
		}

		.col80 {
			flex: 1 0 80% !important;
		}

		.col90 {
			flex: 1 0 90% !important;
		}

		.col100 {
			flex: 1 0 100% !important;
		}

		.comGap {
			display: flex;
			grid-column-gap: 10px;
			flex-direction: row;
			flex-wrap: wrap;
			width: 100%;
			margin: 0px 0px 0px 0px;
		}

		/* SORT- */
		.mkEfeitoSobe {
			position: relative;
		}

		.mkEfeitoSobe::before {
			content: "\2191";
			font-size: 1rem;
			position: absolute;
			right: 0;
			top: -1px;
			height: 100%;
			animation: mkSortY 3s infinite reverse cubic-bezier(0.4, -0.4, 0, 1);
		}

		.mkEfeitoSobe::after {
			content: "";
			display: flex;
			position: absolute;
			top: 0px;
			right: 0px;
			width: 100%;
			height: 100%;
			background: linear-gradient(0turn,
					transparent,
					transparent,
					transparent,
					transparent,
					transparent,
					transparent,
					var(--efeitoSobe),
					transparent,
					transparent,
					transparent,
					transparent,
					transparent,
					transparent);
			border-radius: 2px;
			background-size: auto 400%;
			animation: mkMoveFundoY 3s infinite reverse;
			animation-timing-function: cubic-bezier(0.65, 0.05, 0.36, 1);
			mix-blend-mode: color-dodge;
		}

		.mkEfeitoDesce {
			position: relative;
		}

		.mkEfeitoDesce::before {
			content: "\2193";
			font-size: 1rem;
			position: absolute;
			top: -1px;
			height: 100%;
			right: 0;
			animation: mkSortY 3s infinite cubic-bezier(1, 0, 0.4, 1.4);
		}

		@keyframes mkSortY {
			0% {
				opacity: 0;
				transform: translateY(0%);
			}

			20% {
				opacity: 1;
				transform: translateY(0%);
			}

			80% {
				opacity: 1;
				transform: translateY(50%);
			}

			100% {
				opacity: 0;
				transform: translateY(50%);
			}
		}

		.mkEfeitoDesce::after {
			content: "";
			display: flex;
			position: absolute;
			top: 0px;
			right: 0px;
			width: 100%;
			height: 100%;
			background: linear-gradient(0turn,
					transparent,
					transparent,
					transparent,
					transparent,
					transparent,
					transparent,
					#00d1c3,
					transparent,
					transparent,
					transparent,
					transparent,
					transparent,
					transparent);
			border-radius: 2px;
			background-size: auto 400%;
			animation: mkMoveFundoY 3s infinite;
			animation-timing-function: cubic-bezier(0.65, 0.05, 0.36, 1);
			mix-blend-mode: color-dodge;
		}

		@keyframes mkMoveFundoY {
			0% {
				background-position-y: 100%;
			}

			100% {
				background-position-y: 0%;
			}
		}

		/* EFEITO CLIP */
		.mkEfeitoClip {
			clip-path: url(#mkClip);
		}

		/* LISTAGEM */
		.divListagem {
			overflow: auto;
			border-radius: 10px;
			margin: 3px;
		}

		.tableListagem {
			width: 100%;
			border-collapse: collapse;
		}

		.tableListagem thead {
			position: sticky;
			top: -1px;
			user-select: none;
		}

		.tableListagem th {
			text-align: center;
		}

		/* =======================
	Paginação Padrao
=========================*/
		.pagBotoes {
			display: flex;
			flex-direction: row;
			user-select: none;
			justify-content: center;
		}

		.pagBotao {
			cursor: pointer;
		}

		.pagBotao.disabled {
			filter: grayscale(1);
			opacity: 0.5;
			pointer-events: none;
		}

		.pagBotoes .pagBotao {
			padding: 0.2rem 0.8rem;
			border: 1px solid var(--bordaMaster);
			background-color: var(--fundoLink);
			color: var(--corLink);
		}

		.pagBotoes .ativo {
			background-color: var(--fundoHead);
			color: var(--corHead);
		}

		.pagBotoes .pagBotao:hover {
			background-color: var(--fundoHead);
			color: var(--corHead);
		}

		.pagBotao.pag0 {
			border-bottom-left-radius: 20px;
			border-top-left-radius: 0px;
		}

		.pagBotao.pag8 {
			border-bottom-right-radius: 20px;
			border-top-right-radius: 0px;
		}

		/* Listagem: Paginacao */
		.pagination {
			display: flex;
			flex-direction: row;
			user-select: none;
		}

		.paginate_button {
			cursor: pointer;
		}

		.paginate_button.disabled {
			filter: grayscale(1);
		}

		.page-link {
			padding: 0.5rem 0.8rem;
			line-height: normal;
		}

		/*Layout*/
		.i {
			display: flex;
			flex-direction: row;
		}

		.j {
			flex: 1 0 0%;
		}

		.iSemGap {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			width: 100%;
			margin: 0px 0px 0px 0px;
		}

		.iComGap {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			width: 100%;
			margin: 0px 0px 0px 0px;
			gap: 10px;
		}

		@media (max-width: 767px) {
			.i {
				flex-direction: column;
			}

			.iComGap {
				flex-direction: column;
			}
		}

		*.fsb {
			display: flex !important;
			flex-wrap: wrap !important;
			justify-content: space-between !important;
		}

		*.tb,
		*.ftb {
			display: flex !important;
			flex-direction: column !important;
		}

		.mkCem {
			width: 100%;
			height: 100%;
		}

		/*Desativar via CSS*/
		.disabled {
			pointer-events: none;
		}

		.bordaDupla {
			border: 3px double var(--bordaMaster);
			border-radius: 5px;
		}


		.bordaBaixo {
			border-bottom: 1px solid var(--bordaMaster);
		}

		.pad5 {
			padding: 5px;
		}

		.relative {
			position: relative;
		}

		.absolute {
			position: absolute;
		}

		.pointer {
			cursor: pointer;
		}

		/* NAO FUNCIONA EM CONJUNTO AOS microPos */
		.corte {
			width: 100% !important;
			white-space: nowrap !important;
			overflow: hidden !important;
			text-overflow: ellipsis;
		}

		/* MKBot */
		.mkBot {
			position: relative;
			padding: 0;
		}

		.mkBot .mkBotSobre {
			position: absolute;
			background-color: transparent;
			width: 100%;
			height: 100%;
			left: 0;
			top: 0;
		}

		.mkBot * {
			user-select: none;
			border-radius: inherit;
		}

		/* Recomendador */
		.mkRecList {
			display: flex;
			flex-direction: column;
			position: fixed;
			padding: 5px;
			border-radius: 5px;
			background: var(--FundoItensBgEC);
			max-height: 300px;
			overflow: auto;
			z-index: calc(var(--mkSelIndex));
		}

		.mkRecList .recItem {
			padding: 5px;
			border-bottom: 1px solid var(--BordaItens);
		}

		.mkRecList.emFoco {
			display: none;
		}
	</style>
	<!-- FIM MK CSS -->

	<!-- SITE -->
	<style>
		:root {
			--borderMaster: #4400c3;
			--borderLeve: #c5b5ff;
			--titulo: #4400c3;
			--tituloContra: #fff;
			--tituloContraOposto: #000;
			--link: #5b00e3;
			--fundoLink: #c5b5ff;
			--fundoPar: #f3eeff;
			--fundo: #eeffff;
			--bgEnviando: #8b6bff;
			--fundoHead: var(--titulo);
			--corHead: var(--tituloContra);
			--bordaMaster: var(--borderMaster);
			--corLink: var(--link);
			--tClaroTextoHigh: var(--titulo) !important;
		}

		/* SETS*/
		html {
			font-size: 12pt;
		}

		::-webkit-scrollbar {
			width: 5px;
			height: 5px;
		}

		::-webkit-scrollbar-track {
			background-color: transparent;
		}

		::-webkit-scrollbar-thumb {
			border-radius: 15px;
			border: 5px double var(--borderMaster);
		}

		input {
			border: 1px solid transparent;
			outline: 0px;
			border-radius: 3px;
			padding: 4px;
			background-color: var(--borderLeve);
		}

		/* ESTRUTURA*/

		body,
		.body {
			display: flex;
			flex-direction: column;
			border-radius: 15px;
			border: 3px outset var(--borderMaster);
		}

		body {
			height: calc(100vh - 10px);
			margin: 5px;
		}

		.body,
		.listas {
			height: 100%;
			max-height: calc(100vh - 20px);
			margin: 2px;
		}

		header {
			display: flex;
			justify-content: center;
			flex: 0 0 30%;
		}

		h1 {
			font-family: "Comic Sans MS";
			font-size: 4rem;
			color: var(--titulo);
			text-shadow: 1px 1px 1px black;
			margin: auto;
		}

		section {
			flex: 1 1 0%;
			margin: 5px;
			background-color: var(--fundoLink);
			border-radius: 15px;
		}

		section form {
			height: 100%;
			text-align: center;
		}

		section button {
			width: 100%;
			height: 100%;
			color: var(--link);
			background-color: transparent;
			border-radius: 15px;
			border: 2px outset transparent;
		}

		/*UPLOAD*/
		.descarregavel {
			outline: 1px dashed var(--borderMaster);
			outline-offset: -5px;
			transition: 0.2s ease-in-out;
			padding: 10px;
			display: flex;
			justify-content: center;
			align-items: center;
			text-align: center;
		}

		.descarregavel label {
			height: 100%;
			width: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			flex-direction: column;
		}

		.descarregavel label:has(svg) {
			flex-direction: row;
		}

		.descarregavel svg {
			margin-right: 5px;
		}

		.descarregavel span {
			font-weight: bold;
		}

		.carga {
			outline-offset: 0px;
			background-color: var(--bgEnviando);
		}

		/* TABELA */
		.divListagemContainer {
			border: 1px solid var(--borderMaster);
			border-radius: 10px;
			height: calc(100% - 143px);
		}

		.divListagemContainer .divListagem {
			position: relative;
			overflow: auto;
			border-radius: 10px;
			height: 100%;
			border: 1px solid var(--borderLeve);
			max-height: calc(100% - 6px);
		}

		.divListagem {
			width: 100%;
		}

		.divListagemContainer thead {
			position: sticky;
			top: 0px;
		}

		.divListagemContainer th {
			background-color: var(--titulo);
			border: 1px solid var(--borderLeve);
			color: var(--tituloContra);
			height: 40px;
			text-shadow: 1px 1px 1px var(--tituloContraOposto);
		}

		.divListagemContainer tr {
			background-color: var(--fundo);
		}

		.divListagemContainer tr:nth-child(2n) {
			background-color: var(--fundoPar);
		}

		.divListagemContainer td {
			border: 1px solid var(--borderLeve);
			height: 40px;
			padding: 2px;
		}

		.ColCell {
			padding: 0px 5px;
			overflow: auto;
			text-align: center;
			width: var(--w);
			min-width: var(--w);
			max-width: var(--w);
		}

		.ColCell input {
			width: 100%;
		}

		.divListagem td:nth-child(1) {
			text-align: left;
			--w: auto;
		}

		.divListagem td:nth-child(2) {
			--w: 150px;
		}

		.divListagem td:nth-child(3) {
			--w: 80px;
		}

		.divListagem td:nth-child(4) {
			--w: 60px;
		}

		.divListagem td:nth-child(5) {
			--w: 60px;
		}

		.btnCrud button {
			padding: 4px 0px;
			width: 90%;
		}

		.btnCrud button svg {
			width: 20px;
			height: 20px;
		}

		/* BOTOES */
		.botoes {
			padding: 5px;
		}

		.botoes button {
			width: 100%;
			font-weight: bold;
		}

		.botoes button svg {
			width: 20px;
			height: 20px;
			fill: black;
		}

		.botoes button span {
			margin-left: 5px;
		}

		.operacaoCampos {
			margin: 20px auto;
			display: flex;
			flex-direction: column;
			row-gap: 15px;
		}

		.iNovo {
			min-width: 200px;
		}

		/* mkConfirmador */
		.mkConfirmadorBloco .mkConfirmadorTitulo svg {
			fill: var(--fundoLink);
		}

		.botoes .j {
			display: flex;
			flex-direction: column;
			gap: 10px;
		}
	</style>
	<!-- FIM SITE CSS -->
</head>
<!-- FIM HEAD -->

<body>
	<!-- MENU ENTRADA -->
	<div class="body" ondrop="aoDescarregar(event)" ondragover="aoPassarCarga(event)">
		<header>
			<h1>Tudo OK?</h1>
		</header>
		<section>
			<button type="button" onclick="aoClicarCriar()">Novo</button>
		</section>
		<section class="descarregavel">
			<label for="file"><span>Abrir arquivo</span><br /><br /><em>Arraste ou clique aqui.</em></label>
			<input type="file" name="arquivo" id="file" multiple="" class="mkSecreto" onchange="aoAlterarInput(event);" />
		</section>
	</div>

	<!-- LISTAGEM -->
	<div class="listas oculto">
		<table>
			<tr>
				<td class="ColCell">
					Título<br /><input type="text" name="mTit" class="iConsultas" data-mkfformato="string" />
				</td>
				<td class="ColCell">
					SubTítulo<br /><input type="text" name="mTit2" class="iConsultas" data-mkfformato="string" />
				</td>
				<td class="ColCell">
					Data<br /><input type="text" name="mDat" class="iConsultas" data-mkfformato="string" />
				</td>
				<td class="ColCell">
					Descrição<br /><input type="text" name="mDes" class="iConsultas" data-mkfformato="string" />
				</td>
			</tr>
		</table>
		<div class="divListagemContainer" id="tabela1">
			<div class="divListagem">
				<table class="tableListagem">
					<thead>
						<tr>
							<th class="sort-mTit">Título</th>
							<th class="sort-mTit2">SubTítulo</th>
							<th class="sort-mDat">Data</th>
							<th class="">Editar</th>
							<th class="">Excluir</th>
						</tr>
					</thead>
					<tbody class="listBody"></tbody>
				</table>
			</div>
		</div>
		<div class="iComGap fsb botoes">
			<div class="j">
				<button class="bBotao bCinza microPos5" type="button" onclick="uiGetADD(0)">
					<svg xmlns="http://www.w3.org/2000/svg" fill="bCinza" class="bi bi-plus-circle" viewBox="0 0 16 16">
						<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z" />
						<path
							d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
					</svg>
					<span>Adicionar</span>
				</button>
			</div>
			<div class="j">
				<button class="bBotao bVerde microPos5" type="button" onclick="aoExportar()">
					<svg xmlns="http://www.w3.org/2000/svg" fill="bVerde" viewBox="0 0 16 16">
						<path
							d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z" />
						<path
							d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z" />
					</svg>
					<span>Codificado</span>
				</button>
			</div>
			<div class="j">
				<button class="bBotao bVermelho microPos5" type="button" onclick="aoImportarDescodificado()">
					<svg xmlns="http://www.w3.org/2000/svg" fill="bVermelho" viewBox="0 0 16 16">
						<path fill-rule="evenodd"
							d="M8 5.5a.5.5 0 0 1 .5.5v1.5H10a.5.5 0 0 1 0 1H8.5V10a.5.5 0 0 1-1 0V8.5H6a.5.5 0 0 1 0-1h1.5V6a.5.5 0 0 1 .5-.5z" />
						<path
							d="M4.406 3.342A5.53 5.53 0 0 1 8 2c2.69 0 4.923 2 5.166 4.579C14.758 6.804 16 8.137 16 9.773 16 11.569 14.502 13 12.687 13H3.781C1.708 13 0 11.366 0 9.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383zm.653.757c-.757.653-1.153 1.44-1.153 2.056v.448l-.445.049C2.064 6.805 1 7.952 1 9.318 1 10.785 2.23 12 3.781 12h8.906C13.98 12 15 10.988 15 9.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 4.825 10.328 3 8 3a4.53 4.53 0 0 0-2.941 1.1z" />
					</svg>
					<span>Descodificado</span>
				</button>
				<button class="bBotao bVermelho microPos5" type="button" onclick="aoExportarDescodificado()">
					<svg xmlns="http://www.w3.org/2000/svg" fill="bVermelho" viewBox="0 0 16 16">
						<path
							d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z" />
						<path
							d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z" />
					</svg>
					<span>Descodificado</span>
				</button>
			</div>
			<div class="j">
				<button class="bBotao bVermelho microPos5" type="button" onclick="aoSair()">
					<svg xmlns="http://www.w3.org/2000/svg" fill="bVermelho" viewBox="0 0 16 16">
						<path fill-rule="evenodd"
							d="M6 12.5a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v2a.5.5 0 0 1-1 0v-2A1.5 1.5 0 0 1 6.5 2h8A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-8A1.5 1.5 0 0 1 5 12.5v-2a.5.5 0 0 1 1 0v2z" />
						<path fill-rule="evenodd"
							d="M.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L1.707 7.5H10.5a.5.5 0 0 1 0 1H1.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z" />
					</svg>
					<span>Sair</span>
				</button>
				<input type="file" name="importar" id="file" multiple="" class="mkSecreto"
					onchange="aoAlterarInputImport(event);" />
			</div>
		</div>
	</div>

	<!-- OPERACAO CRUD -->
	<div id="Acao" class="operacaoContainer oculto">
		<header>
			<h1 class="operacaoTitulo">Adicionar</h1>
		</header>
		<form class="operacaoCampos"></form>
		<div class="iComGap fsb botoes">
			<div class="j">
				<button class="bBotao bVerde microPos5 operacaoBotao" type="button" onclick="">
					<svg xmlns="http://www.w3.org/2000/svg" class="operacaoAcaoIco" fill="bCinza" viewBox="0 0 16 16">
						<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z" />
						<path
							d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
					</svg>
					<span class="operacaoAcao">Adicionar</span>
				</button>
			</div>
			<div class="j">
				<button class="bBotao bCinza microPos5" type="button" onclick="aoClicarNivel2Cancelar()">
					<svg xmlns="http://www.w3.org/2000/svg" fill="bCinza" viewBox="0 0 16 16">
						<path
							d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z" />
					</svg>
					<span>Cancelar</span>
				</button>
			</div>
		</div>
	</div>
</body>

<!-- SCRIPTS -->
<!-- MODELO DE ADICIONAR E EDITAR -->
<script type="text/html" id="modeloOperacao">
		<div class="iComGap bordaBaixo">
			<div class="j">${l}</div>
			<div class="j">
				<${t} ${a} name="${k}" class="iNovo" value="${v}">${i}</${t}>
			</div>
		</div>
	</script>

<!-- MODELO LISTAGEM -->
<script type="text/html" id="modelo" pk="mCod" ob="mTit" od="0">
		<tr id="${mCod}">
			<td class="ColCell sort-mTit">${mTit}</td>
			<td class="ColCell sort-mTit2">${mTit2}</td>
			<td class="ColCell sort-mDat">${mDat}</td>
			<td class="ColCell btnCrud">
				<button
					class="bBotao bCinza"
					type="button"
					onclick="uiGetEDIT(mk.getTr(this),0);"
				>
					<svg
						xmlns="http://www.w3.org/2000/svg"
						fill="bCinza"
						viewBox="0 0 16 16"
					>
						<path
							d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"
						/>
						<path
							fill-rule="evenodd"
							d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"
						/>
					</svg>
				</button>
			</td>
			<td class="ColCell btnCrud">
				<button
					class="bBotao bVermelho"
					type="button"
					onclick="uiGetDEL(mk.getTr(this),0);"
				>
					<svg
						xmlns="http://www.w3.org/2000/svg"
						fill="bCinza"
						viewBox="0 0 16 16"
					>
						<path
							d="M14 3a.702.702 0 0 1-.037.225l-1.684 10.104A2 2 0 0 1 10.305 15H5.694a2 2 0 0 1-1.973-1.671L2.037 3.225A.703.703 0 0 1 2 3c0-1.105 2.686-2 6-2s6 .895 6 2zM3.215 4.207l1.493 8.957a1 1 0 0 0 .986.836h4.612a1 1 0 0 0 .986-.836l1.493-8.957C11.69 4.689 9.954 5 8 5c-1.954 0-3.69-.311-4.785-.793z"
						/>
					</svg>
				</button>
			</td>
		</tr>
	</script>

<!-- MK LIB -->
<script defer>
	// INICIO UPDATE MKLIB
	"use strict";
	// Transformar para uma unidade / modulado. Dependencias diretas/indiretas:
	// - $ JQuery Framework JS
	// - $ Mask
	// - $ Print
	// - $ Unobtrutive Validate (Está vinculado ao Data Annotation do C#)
	// - Bootstrap Toast
	// - Bootstrap Dropdown (quase)
	// - Bootstrap Modal
	// - Poper
	var mkt; // Variavel de Testes;
	var mkt2; // Variavel de Testes;
	//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
	//			CLASSE MK Instanciavel			\\
	//___________________________________\\
	class mk {
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			PROPRIEDADES								\\
		//___________________________________\\
		// Armazenadores
		dadosFull = []; // Todos os dados sem filtro, mas ordenaveis.
		dadosFiltrado = []; // Mesmos dadosFull, mas após filtro.
		dadosExibidos = []; // Clonado de dadosFiltrado, mas apenas os desta pagina.
		alvo = {}; // Guarda o objeto selecionado permitindo manupular outro dado com este de referencia.
		thisListNum = 0;
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			CONSTRUTOR (contrutor)			\\
		//___________________________________\\
		// É possível construir o objeto usando undefined ou null para atingir os valores padrão.
		constructor(urlOrigem = mk.delUrlQuery(window.location.href) + "/GetList", todaListagem = ".divListagemContainer", idModelo = "#modelo", filtro = ".iConsultas", arg = null) {
			this.thisListNum = ++mk.contaListas;
			if (idModelo == null || idModelo == "")
				idModelo = "#modelo";
			// ReSET dos parametros (Null para Valor Padrão)
			if (urlOrigem == null || urlOrigem === "") {
				urlOrigem = (mk.delUrlQuery(window.location.href) + "/GetList").replaceAll("//GetList", "/GetList");
			}
			else {
				if (typeof urlOrigem == "string") {
					urlOrigem = urlOrigem.replaceAll("//GetList", "/GetList");
				}
			}
			if (todaListagem == null || todaListagem == "")
				todaListagem = ".divListagemContainer";
			if (filtro == null || filtro == "")
				filtro = ".iConsultas";
			// Objeto de parametros
			if (arg == null)
				arg = {};
			if (arg.importar == null)
				arg.importar = false;
			if (arg.aoReceberDados == null)
				arg.aoReceberDados = mk.aoReceberDados;
			if (arg.modicaFiltro == null)
				arg.modicaFiltro = this.modicaFiltro;
			if (arg.antesDePopularTabela == null)
				arg.antesDePopularTabela = mk.antesDePopularTabela;
			if (arg.aoCompletarExibicao == null)
				arg.aoCompletarExibicao = mk.aoCompletarExibicao;
			if (arg.keys == null)
				arg.keys = [];
			// Setando Config
			this.listagemConfigurar(urlOrigem, todaListagem, idModelo, filtro, arg);
			this.aoReceberDados = arg.aoReceberDados;
			this.modicaFiltro = arg.modicaFiltro;
			this.antesDePopularTabela = arg.antesDePopularTabela;
			this.aoCompletarExibicao = arg.aoCompletarExibicao;
			// Finaliza Contrutor chamando o método de coleta
			this.getList(arg.importar);
		}
		// Fn Individuais da Listagem.
		aoReceberDados = (objeto) => {
			return objeto;
		};
		antesDePopularTabela = () => { };
		modicaFiltro = (obj) => {
			let resultado = true;
			//if(obj.X == "Y") return false;
			return resultado;
		};
		aoCompletarExibicao = () => { };
		antesDeOrdenar = () => { };
		// Por garantia a funcao async para o carregador da lista esperar a funcao concluir.
		antesDeOrdenarAsync = async () => {
			return new Promise((r) => {
				this.antesDeOrdenar();
				r(true);
			});
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			CONFIGURACOES								\\
		//___________________________________\\
		c = {
			objFiltro: {},
			divTabela: ".divListagemContainer",
			urlOrigem: "",
			pagAtual: 1,
			tablePorPagina: null,
			tableTotal: null,
			sortBy: "",
			sortDir: false,
			totalFull: this.dadosFull.length,
			totalFiltrado: this.dadosFiltrado.length,
			totalExibidos: this.dadosExibidos.length,
			pagPorPagina: 5,
			pagItensIni: 0,
			pagItensFim: 0,
			totPags: 0,
			pk: null, // Possivel setar o nome do campo que é primary key já na construcao
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			LISTAGEM										\\
		//___________________________________\\
		// Seta as variaveis de uso interno.
		listagemConfigurar = (urlOrigem, todaListagem, idModelo, fTag, arg) => {
			this.c.urlOrigem = urlOrigem;
			this.c.filtro = fTag;
			this.c.divTabela = todaListagem;
			this.c.idModelo = idModelo;
			this.c.tbody = todaListagem + " tbody";
			this.c.ths = todaListagem + " th";
			this.c.pagBotoes = todaListagem + " .pagBotoes";
			this.c.tableResultado = todaListagem + " .tableResultado";
			this.c.tablePorPagina = todaListagem + " input[name='tablePorPagina']";
			this.c.tableExibePorPagina = todaListagem + " .tableExibePorPagina";
			this.c.tableTotal = this.c.divTabela + " .tableTotal";
			this.c.tableFiltrado = this.c.divTabela + " .tableFiltrado";
			this.c.tableIni = this.c.divTabela + " .tableIni";
			this.c.tableFim = this.c.divTabela + " .tableFim";
			this.c.tableInicioFim = this.c.divTabela + " .tableInicioFim";
			this.c.pag = this.c.pagBotoes + " .pag";
			this.c.pagBotao = this.c.pagBotoes + " .pagBotao";
			this.c.m = arg.keys;
			// Primary Key
			if (!arg.pk) {
				// PrimaryKey do Parametro tem preferência sobre Modelo.
				// Quando PrimaryKey não informada no parametro, tentar usar a do modelo.
				this.c.pk = mk.Q(idModelo)?.getAttribute("pk");
				// Quando Não está nem no parametro e nem no modelo, padrão "pk";
				if (!this.c.pk)
					this.c.pk = "pk";
			}
			else {
				this.c.pk = arg.pk;
			}
			let sortBy = mk.Q(idModelo)?.getAttribute("ob");
			if (!sortBy)
				sortBy = this.c.pk;
			let sortDir = mk.Q(idModelo)?.getAttribute("od");
			if (!sortDir)
				sortDir = 1;
			this.setDirSort(sortBy, Number(sortDir));
		};
		// Iterator
		[Symbol.iterator]() {
			let iteratorArray = this.dadosFull[Symbol.iterator]();
			// Iteration result
			return {
				next() {
					return iteratorArray.next();
				},
				// Iterable
				[Symbol.iterator]() {
					return this;
				},
			};
		}
		// Criar eventos para UI permitindo o usuario interagir com a tabela.
		configurarUI = () => {
			if (mk.Q(this.c.divTabela)) {
				// Seta Gatilho dos botoes de paginacao.
				mk.QAll(this.c.pagBotao).forEach((li) => {
					li.addEventListener("click", (ev) => {
						this.mudaPag(ev.target);
					});
				});
				// Seta Gatilho do indicador de quantidade por pagina.
				if (mk.Q(this.c.tablePorPagina)) {
					mk.Ao("input", this.c.tablePorPagina, async () => {
						this.atualizaNaPaginaUm();
					});
				}
				this.ativarSort();
			}
		};
		// Metodo que prepara a listagem e inicia a coleta.
		getList = async (importar = false) => {
			// Verifica e importa resumo da tabela se necessario.
			if (importar)
				await mk.importar(this.c.divTabela);
			this.configurarUI();
			// Caso o receba uma array na url, os dados já estão aqui.
			let temosDados = null;
			if (Array.isArray(this.c.urlOrigem)) {
				temosDados = mk.clonar(this.c.urlOrigem);
			}
			else {
				// Inicia o Coleta de dados
				let pac = await mk.get.json(this.c.urlOrigem);
				if (pac.retorno != null) {
					temosDados = pac.retorno;
				}
			}
			if (temosDados != null) {
				// Limpar Dados nulos
				mk.mkLimparOA(temosDados);
				// Executa funcao personalizada por página
				mk.mkExecutaNoObj(temosDados, this.aoReceberDados);
				// Armazena em 1 array que está em 2 locais na memória
				this.dadosFull = this.dadosFiltrado = temosDados;
				// Executa função antes de ordenar a tabela (Util para calcular coisas no conteudo recebido)
				await this.antesDeOrdenarAsync();
				// Ordena a lista geral com base na primeira propriedade.
				mk.ordenamento(this.dadosFull, this.c.sortBy, this.c.sortDir);
				//Adiciona eventos aos botões do filtro
				this.setFiltroListener();
				// Executa um filtro inicial e na sequencia processa a exibição.
				this.updateFiltro();
				this.efeitoSort();
				// Remove oculto, caso encontre a tag
				if (mk.Q(this.c.tableResultado))
					mk.Q(this.c.tableResultado).classList.remove("oculto");
			}
		};
		/**
		 * ATUALIZA a listagem com os dados ja ordenados.
		 * Executa a filtragem dos dados;
		 */
		atualizarListagem = async () => {
			let pagBotoes = mk.Q(this.c.pagBotoes);
			// Processo de filtro que usa o objFiltro nos dadosFull e retorna dadosFiltrado já filtrado.
			this.dadosFiltrado = mk.processoFiltragem(this.dadosFull, this.c.objFiltro, this);
			// Processar calculos de paginacao
			this.atualizarStatusListagem();
			// Apenas executa a atualização do resumo, se a pagBotoes estiver presente na página.
			if (this.c.totalFiltrado > this.c.pagPorPagina)
				pagBotoes?.removeAttribute("hidden");
			else
				pagBotoes?.setAttribute("hidden", "");
			if (this.c.totalFiltrado == 0) {
				mk.Q(this.c.tableInicioFim)?.setAttribute("hidden", "");
				mk.Q(this.c.tableExibePorPagina)?.setAttribute("hidden", "");
				mk.Q(this.c.tbody)?.setAttribute("hidden", "");
				this.dadosExibidos = [];
			}
			else {
				if (pagBotoes) {
					mk.Q(this.c.tableInicioFim)?.removeAttribute("hidden");
					mk.Q(this.c.tableExibePorPagina)?.removeAttribute("hidden");
					this.processoPaginar();
				}
				else {
					// Caso não tenha onde paginar, exibe geral sem clonar.
					this.dadosExibidos = this.dadosFiltrado;
				}
				mk.Q(this.c.tbody)?.removeAttribute("hidden");
				this.antesDePopularTabela();
				await mk.mkMoldeOA(this.dadosExibidos, this.c.idModelo, this.c.tbody);
				this.aoCompletarExibicao();
			}
		};
		// Atualiza o objeto que contem os dados desta instancia.
		atualizarStatusListagem = () => {
			if (mk.Q(this.c.tablePorPagina) == null) {
				this.c.pagPorPagina = 5;
			}
			else {
				this.c.pagPorPagina = Number(mk.Q(this.c.tablePorPagina).value);
			}
			this.c.totalFull = this.dadosFull.length;
			this.c.totalFiltrado = this.dadosFiltrado.length;
			this.c.totalExibidos = this.dadosExibidos.length;
			this.c.pagItensIni = (this.c.pagAtual - 1) * this.c.pagPorPagina + 1; // Calculo Pagination
			this.c.pagItensFim = this.c.pagItensIni + (this.c.pagPorPagina - 1); // Calculo genérico do último
			if (this.c.pagItensFim > this.c.totalFiltrado)
				this.c.pagItensFim = this.c.totalFiltrado; // Na última página não pode exibir o valor genérico.
			// Arredondar pra cima, pois a última página pode exibir conteúdo sem preencher o PorPagina
			this.c.totPags = Math.ceil(this.dadosFiltrado.length / this.c.pagPorPagina);
			// Atualizar o Status processado no resumo da tabela
			mk.html(this.c.tableTotal, this.c.totalFull.toString());
			mk.html(this.c.tableFiltrado, this.c.totalFiltrado.toString());
			mk.html(this.c.tableIni, this.c.pagItensIni.toString());
			mk.html(this.c.tableFim, this.c.pagItensFim.toString());
		};
		// Retorna a pagina 1 e atualiza
		atualizaNaPaginaUm = async () => {
			this.c.pagAtual = 1;
			this.atualizarListagem();
		};
		// Gatilho para trocar a pagina
		mudaPag = (e) => {
			if (e.classList.contains("pag0")) {
				// Anterior
				if (this.c.pagAtual >= 2)
					this.c.pagAtual -= 1;
			}
			else if (e.classList.contains("pag8")) {
				// Proximo
				this.c.pagAtual += 1;
			}
			else {
				this.c.pagAtual = Number(e.innerHTML);
			}
			this.atualizarListagem();
		};
		// Monta os botoes de numero de pagina
		processoPaginar = () => {
			// Links
			mk.html(this.c.pag + "7", this.c.totPags.toString());
			this.c.pagAtual == 1 ? mk.Qoff(this.c.pag + "0") : mk.Qon(this.c.pag + "0");
			if (this.c.totPags > 1) {
				mk.QverOn(this.c.pag + "0");
				mk.QverOn(this.c.pag + "8");
				mk.QverOn(this.c.pag + "7");
			}
			else {
				mk.QverOff(this.c.pag + "0");
				mk.QverOff(this.c.pag + "8");
				mk.QverOff(this.c.pag + "7");
			}
			this.c.pagAtual >= this.c.totPags
				? mk.Qoff(this.c.pag + "8")
				: mk.Qon(this.c.pag + "8");
			mk.QverOn(this.c.pag + "1");
			this.c.totPags > 2
				? mk.QverOn(this.c.pag + "2")
				: mk.QverOff(this.c.pag + "2");
			this.c.totPags > 3
				? mk.QverOn(this.c.pag + "3")
				: mk.QverOff(this.c.pag + "3");
			this.c.totPags > 4
				? mk.QverOn(this.c.pag + "4")
				: mk.QverOff(this.c.pag + "4");
			this.c.totPags > 5
				? mk.QverOn(this.c.pag + "5")
				: mk.QverOff(this.c.pag + "5");
			this.c.totPags > 6
				? mk.QverOn(this.c.pag + "6")
				: mk.QverOff(this.c.pag + "6");
			if (this.c.pagAtual < 5 || this.c.totPags == 5 || this.c.totPags == 6) {
				// INI
				mk.Qon(this.c.pag + "2");
				mk.html(this.c.pag + "2", "2");
				mk.html(this.c.pag + "3", "3");
				mk.html(this.c.pag + "4", "4");
				mk.html(this.c.pag + "5", "5");
				mk.html(this.c.pag + "6", "...");
				mk.Qoff(this.c.pag + "6");
			}
			else {
				// END
				if (this.c.totPags - this.c.pagAtual < 4) {
					mk.Qoff(this.c.pag + "2");
					mk.html(this.c.pag + "2", "...");
					mk.html(this.c.pag + "3", (this.c.totPags - 4).toString());
					mk.html(this.c.pag + "4", (this.c.totPags - 3).toString());
					mk.html(this.c.pag + "5", (this.c.totPags - 2).toString());
					mk.html(this.c.pag + "6", (this.c.totPags - 1).toString());
					mk.Qon(this.c.pag + "6");
				}
				else {
					// MID
					mk.Qoff(this.c.pag + "2");
					mk.html(this.c.pag + "2", "...");
					mk.html(this.c.pag + "3", (this.c.pagAtual - 1).toString());
					mk.html(this.c.pag + "4", this.c.pagAtual.toString());
					mk.html(this.c.pag + "5", (this.c.pagAtual + 1).toString());
					mk.html(this.c.pag + "6", "...");
					mk.Qoff(this.c.pag + "6");
				}
			}
			// Ativar Pagina
			mk.QAll(this.c.pagBotao).forEach((li) => {
				li.classList.remove("ativo");
				if (this.c.pagAtual == Number(li.innerHTML)) {
					li.classList.add("ativo");
				}
			});
			// Limpar Exibidos
			this.dadosExibidos = [];
			// Clonar Exibidos de Filtrados
			this.dadosFiltrado.forEach((o, i) => {
				if (i + 1 >= this.c.pagItensIni && i + 1 <= this.c.pagItensFim) {
					this.dadosExibidos.push(mk.clonar(o));
				}
			});
		};
		// Limpa e Gera Filtro. Padrao class ".iConsultas".
		updateFiltro = () => {
			// Limpa filtro atual
			this.c.objFiltro = {};
			// Gera filtro os nos campos
			mk.QAll(this.c.filtro).forEach((e) => {
				this.gerarFiltro(e);
			});
			this.atualizaNaPaginaUm();
		};
		// Gerar Filtro baseado nos atributos do MKF gerados no campo.
		gerarFiltro = (e) => {
			// Para ignorar filtro: data-mkfignore="true" (Ou nao colocar o atributo mkfformato no elemento)
			if (e.value != null && e.getAttribute("data-mkfignore") != "true") {
				this.c.objFiltro[e.name] = {
					formato: e.getAttribute("data-mkfformato"),
					operador: e.getAttribute("data-mkfoperador"),
					conteudo: e.value,
				};
			}
			// Limpar filtro caso o usuario limpe o campo
			if (this.c.objFiltro[e.name]["conteudo"] == "" ||
				this.c.objFiltro[e.name]["conteudo"] == "0" ||
				this.c.objFiltro[e.name]["conteudo"] == 0 ||
				this.c.objFiltro[e.name]["conteudo"] === null) {
				delete this.c.objFiltro[e.name];
			}
		};
		// Gerar Gatilhos de FILTRO
		setFiltroListener = () => {
			mk.QAll(this.c.filtro).forEach((e) => {
				e.addEventListener("input", () => {
					this.gerarFiltro(e);
					this.atualizaNaPaginaUm();
				});
			});
		};
		// Gera Listeners na THEAD da tabela (Requer classe: "sort-campo")
		ativarSort = () => {
			let eTrHeadPai = mk.Q(this.c.divTabela + " thead tr");
			Array.from(eTrHeadPai.children).forEach((th) => {
				let ordenar = false;
				th.classList.forEach((classe) => {
					// Verifica se contém sort- no inicio da class
					if (classe.indexOf("sort-") == 0) {
						ordenar = classe;
					}
				});
				if (ordenar != false) {
					let campo = ordenar.replace("sort-", "");
					if (campo != "") {
						mk.Ao("click", this.c.divTabela + " thead .sort-" + campo, () => {
							this.orderBy(campo);
						});
					}
				}
			});
		};
		// Direção 0: Crescente
		// Direção 1: Decrescente
		// Direção 2: Toogle
		setDirSort = (propriedade, direcao = 2) => {
			if (propriedade != null) {
				if (direcao == 2) {
					if (propriedade != this.c.sortBy) {
						this.c.sortDir = 0;
					}
					else {
						this.c.sortDir == 0 ? (this.c.sortDir = 1) : (this.c.sortDir = 0);
					}
				}
				else if (direcao == 1) {
					this.c.sortDir = 1;
				}
				else {
					this.c.sortDir = 0;
				}
				this.c.sortBy = propriedade;
			}
			//mk.l("By: ", this.c.sortBy, " | Dir: ", this.c.sortDir);
		};
		// Ordena a lista e atualiza (Direcao: 0,1,2(toogle))
		orderBy = (propriedade, direcao = 2) => {
			// Atualiza atual Sort
			this.setDirSort(propriedade, Number(direcao));
			// Executa Ordenador da lista principal
			this.dadosFull = mk.ordenar(this.dadosFull, this.c.sortBy, this.c.sortDir);
			// Atualiza classes indicadoras de ordem
			this.efeitoSort();
			this.atualizarListagem();
		};
		efeitoSort = () => {
			// Limpa efeito
			let thsAll = mk.QAll(this.c.ths);
			if (thsAll.length != 0) {
				thsAll.forEach((th) => {
					th.classList.remove("mkEfeitoDesce");
					th.classList.remove("mkEfeitoSobe");
				});
			}
			// Busca elemento que está sendo ordenado
			let thsSort = mk.QAll(this.c.ths + ".sort-" + this.c.sortBy);
			if (thsSort.length != 0) {
				thsSort.forEach((thSort) => {
					if (this.c.sortDir == 1) {
						thSort.classList.add("mkEfeitoDesce");
					}
					else {
						thSort.classList.add("mkEfeitoSobe");
					}
				});
			}
		};
		// LIMPAR FILTRO  LimparFiltro("#consulta_form"); //Passar o form que contem os SELECT/INPUT de filtro (search).
		clearFiltro = () => {
			this.c.objFiltro = {};
			// RESET Form (Limpar seria "0" / "") (Set e.defaultValue)
			mk.QAll(this.c.filtro).forEach((e) => {
				e.value = "";
			});
			// Solicita Atualizacao de todos mkSel
			mk.QAll(this.c.filtro + ".mkSel").forEach((mkSel) => {
				mkSel.classList.add("atualizar");
			});
		};
		// LIMPAR FILTRO  LimparFiltro("#consulta_form"); //Passar o form que contem os SELECT/INPUT de filtro (search).
		clearFiltroUpdate = () => {
			this.clearFiltro();
			this.atualizarListagem();
		};
		// Retorna o último objeto da lista onde a chave primaria bateu.
		getObj = (valorKey) => {
			let temp = null;
			if (Array.isArray(this.dadosFull)) {
				this.dadosFull.forEach((o) => {
					if (o[this.c.pk] == valorKey) {
						temp = o;
					}
				});
			}
			return temp;
		};
		// Retorna uma lista de todos objetos encontrados onde o KV bateu.
		getObjs = (k, v) => {
			let array = [];
			let errNotPresent = false;
			let errKeyInvalid = false;
			if (Array.isArray(this.dadosFull)) {
				if (typeof k === "string") {
					this.dadosFull.forEach((o) => {
						if (k in o) {
							if (o[k] == v) {
								array.push(o);
							}
						}
						else {
							errNotPresent = true;
						}
					});
				}
				else {
					errKeyInvalid = true;
				}
			}
			if (errNotPresent)
				mk.w("Erro getObjs(): Key não está presente em um ou mais objetos.");
			if (errKeyInvalid)
				mk.w("Erro getObjs(): Key precisa ser no formato string.");
			return array;
		};
		setObj = (v, objeto) => {
			let temp = null;
			if (Array.isArray(this.dadosFull)) {
				let o = this.find(this.c.pk, v);
				if (o) {
					if (typeof objeto == "object") {
						for (let p in objeto) {
							o[p] = objeto[p];
						}
					}
					temp = o;
				}
				else {
					this.dadosFull.push(mk.aoReceberDados(objeto));
					temp = objeto;
				}
			}
			return temp;
		};
		// Modelo de Chaves e Propriedades do Modelo, podendo conter todo o design e estrutura dos dados da lista
		// Formato K V L R (Chave, Valor, Label, Regex) V é vazio/nulo, pois não recebe objeto nessa função.
		getModel = () => {
			return this.c.m;
		};
		// KVLR (E mais...)
		// K (Chave)	- V (Valor) - L (Label) - R (REGEX)	- T (TAG Html) - A (Attributos Tag) - I (Value no Inner)
		// keys.push({ k: "mDat", v: "", l: "Data", r: mk.util.data[1], t: "input", a: "type='text'" });
		// keys.push({ k: "mDes", v: "", l: "Descrição", r: "", t: "textarea", a: "cols='50' rows='10'", i: true });
		// Recebendo o objeto da lista, traz o getUsedKeys juntamente aos Values deste objeto;
		getKVLR = (obj) => {
			let model = this.getModel();
			if (model.length == 0)
				model = this.getUsedKeys(true);
			let kvlr = [];
			model.forEach((m) => {
				let o = { ...m };
				if (obj?.[m.k]) {
					if (o.i == true) {
						o.i = obj?.[m.k];
						o.v = "";
					}
					else {
						o.i = null;
						o.v = obj?.[m.k];
					}
				} else {
					o.i = null;
					o.v = "";
				}
				kvlr.push(o);
			});
			return kvlr;
		};
		// Cria um Set retorna um array de Keys Usadas
		getUsedKeys = (formatoKV = false) => {
			let kv = [];
			let chaves = new Set();
			this.dadosFull.forEach((o) => {
				Object.keys(o).forEach((p) => {
					chaves.add(p);
				});
			});
			if (formatoKV) {
				[...chaves].forEach((k) => {
					let obj = {};
					obj.k = k;
					kv.push(obj);
				});
				return kv;
			}
			else {
				return [...chaves];
			}
		};
		getNewPK = () => {
			let maior = 0;
			this.dadosFull.forEach((o) => {
				if (o[this.c.pk] > maior)
					maior = Number(o[this.c.pk]);
			});
			return Number(maior) + 1;
		};
		getAllTr = () => {
			return Array.from(mk.QAll(this.c.divTabela + " tbody tr"));
		};
		// USER INTERFACE - UI - INDIVIDUAL
		add = (objDados) => {
			this.dadosFull.push(this.aoReceberDados(objDados));
			mk.ordenar(this.dadosFull, this.c.sortBy, this.c.sortDir);
			this.atualizarListagem();
		};
		edit = (objDados, k, v) => {
			this.dadosFull = mk.delObjetoFromId(k, v, this.dadosFull);
			this.dadosFull.push(mk.aoReceberDados(objDados));
			mk.ordenar(this.dadosFull, this.c.sortBy, this.c.sortDir);
			this.atualizarListagem();
		};
		del = (k, v) => {
			this.dadosFull = mk.delObjetoFromId(k, v, this.dadosFull);
			mk.ordenar(this.dadosFull, this.c.sortBy, this.c.sortDir);
			this.atualizarListagem();
		};
		find = (k, v) => {
			return this.dadosFull.find((o) => o[k] == v);
		};
		toJSON = () => {
			return this.dadosFull;
		};
		toString = () => {
			return JSON.stringify(this.dadosFull, null, "\t");
		};
		valueOf = () => {
			return this.dadosFull;
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			ATRIBUTOS	ESTATICOS					\\
		//___________________________________\\
		static contaListas = 0;
		static contaOrdena = 0;
		static paginationAtual = 1;
		static objetoSelecionado = {};
		static sendObjFull = {};
		static mkFaseAtual = 1;
		static mkCountValidate = 0;
		static debug = 0; // 0 / 1
		static timers = []; // Array para guardar timers em andamento ou finalizados
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			TITULOS CONSTANTES					\\
		//___________________________________\\
		static t = {
			G: "GET",
			P: "POST",
			J: "application/json",
			B: "*/*",
			H: "text/html",
			F: "multipart/form-data", // ContentType FORM
		};
		static MESES = [
			"Janeiro",
			"Fevereiro",
			"Março",
			"Abril",
			"Maio",
			"Junho",
			"Julho",
			"Agosto",
			"Setembro",
			"Outubro",
			"Novembro",
			"Dezembro",
		];
		static CORES = {
			VERMELHO: "#F00",
			VERDE: "#0F0",
			AZUL: "#00F",
			BRANCO: "#FFF",
			PRETO: "#000",
			VERDEFLORESTA: "#070",
			VERDEFOLHA: "#0A0",
			VERDEABACATE: "#9F0",
			AMARELO: "#FF0",
			LARANJA: "#F90",
			AZULESCURO: "#009",
			AZULPISCINA: "#0FF",
			AZULCEU: "#09F",
			ROSA: "#F0F",
			ROXO: "#70F",
			MAGENTA: "#F09",
			OURO: "#FB1",
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MASCARAS E REGEX						\\
		//___________________________________\\
		// Ex Regex: mk.util.cpf[1];
		static util = {
			cpf: ["000.000.000-00", /^([0-9]{3}([\.]?[0-9]{3}){2}[-]?[0-9]{2})$/],
			cep: ["00000-000", /^([0-9]{5}[-]?[0-9]{3})$/],
			cnpj: [
				"00.000.000/0000-00",
				/^([0-9]{2}([\.]?[0-9]{3}){2}[\/]?[0-9]{4}[-]?[0-9]{2})$/,
			],
			cpf_cnpj: [
				"00.000.000/0000-00",
				/^([0-9]{2}([\.]?[0-9]{3}){2}[\/]?[0-9]{4}[-]?[0-9]{2})|([0-9]{3}([\.]?[0-9]{3}){2}[-]?[0-9]{2})$/,
			],
			cnh: ["00000000000", /^([0-9]{11})$/],
			placa: ["SSS-0A00", /^([A-Za-z]{3}[-]?[0-9]{1}[A-Za-z0-9]{1}[0-9]{2})$/],
			placaAntesMercosul: ["AAA-0000", /^([A-Za-z]{3}[-]?[0-9]{4})$/],
			placaMercosul: [
				"SSS-0S00",
				/^([A-Za-z]{3}[-]?[0-9]{1}[A-Za-z]{1}[0-9]{2})$/,
			],
			pis: [
				"000.00000.00-0",
				/^([0-9]{3}[\.]?[0-9]{5}[\.]?[0-9]{2}[-]?[0-9]{1})$/,
			],
			money: ["#0.000.000.000.000.000,00"],
			dia: ["00", /^([0-3]?[0-9])$/],
			mes: ["00", /^([0-1]?[0-9])$/],
			ano: ["0000", /^([0-2]?([0-9]){3})$/],
			ip: ["000.000.000.000", /^([0-9]?[0-9]?[0-9]([\.]?[0-9]?[0-9]?[0-9]){3})$/],
			data: ["0000-00-00", /^([0-9]{4}(-[0-9]{2}){2})$/],
			dataIso8601: [
				"0000-00-00T00:00:00.000Z",
				/^([0-9]{4}(-[0-9]{2}){2}T[0-9]{2}(:[0-9]{2})\.[0-9]{3}Z)$/,
			],
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MK FUNCOES UTIL							\\
		//___________________________________\\
		// Classes do Console.
		static w = (...s) => {
			console.warn(...s);
		};
		static l = (...s) => {
			console.log(...s);
		};
		static cls = () => {
			console.clear();
		};
		static gc = (...s) => {
			console.groupCollapsed(...s);
		};
		static ge = () => {
			console.groupEnd();
		};
		static ct = (s) => {
			let t = mk.timers.find((t) => t.name == s);
			if (!t) {
				mk.timers.push({
					name: s,
					ini: mk.getMs(),
					fim: 0,
					tempo: -1,
				});
				// console.time(s);
			}
		};
		static cte = (s, quietMode = false) => {
			let t = mk.timers.find((t) => t.name == s);
			if (t.fim == 0) {
				t.fim = mk.getMs();
				t.tempo = t.fim - t.ini;
			}
			if (!quietMode) {
				mk.l(s + " \t-> " + t.tempo + " ms");
			}
			// console.timeEnd(s);
		};
		// Atalho para QuerySelector que retorna apenas o primeiro elemento da query.
		static Q = (query) => {
			if (typeof query != "string")
				return query;
			return document.querySelector(query);
		};
		// Atalho para QuerySelectorAll. List []
		static QAll = (query = "body") => {
			return Array.from(document.querySelectorAll(query));
		};
		// Atalho para AddEventListener
		static Ao = (tipoEvento = "click", query, executar) => {
			// CONVERTER PARA QUERY SELECTALL pois, tem o Pesquisar que pega todos os .iConsultas
			mk.QAll(query).forEach((e) => {
				e.addEventListener(tipoEvento, () => {
					executar(e);
				});
			});
		};
		// Atalho para innerHTML que retorna apenas o primeiro elemento da query.
		static html = (query, conteudo) => {
			let e = mk.Q(query);
			if (e) {
				e.innerHTML = conteudo;
			}
			return e;
		};
		static isJson = (s) => {
			try {
				JSON.parse(s);
			}
			catch (e) {
				return false;
			}
			return true;
		};
		static removeEspecias = (s) => {
			let r = "";
			let sS = "áàãâäéèêëíìîïóòõôöúùûüçÁÀÃÂÄÉÈÊËÍÌÎÏÓÒÕÖÔÚÙÛÜÇ";
			let sN = "aaaaaeeeeiiiiooooouuuucAAAAAEEEEIIIIOOOOOUUUUC";
			for (let p = 0; p < s.length; p++) {
				if (sS.indexOf(s.charAt(p)) != -1) {
					r += sN.charAt(sS.indexOf(s.charAt(p)));
				}
				else {
					r += s.charAt(p);
				}
			}
			r = mk.apenasNumerosLetras(r);
			return r;
		};
		static range = (from, to) => {
			// Obtem-se o acesso a um range de numeros.
			// Ambos os parametros são necessários: FROM(DE) e TO(PARA)
			class Range {
				// Propriedades
				from; // <= Número Inicial
				to; // <= Número Final
				// Contrutor
				constructor(from, to) {
					this.from = from;
					this.to = to;
				}
				has(x) {
					return typeof x === "number" && this.from <= x && x <= this.to;
				}
				// Representação matemática do range.
				toString() {
					return `{ x | ${this.from} <= x <= ${this.to} }`;
				}
				// Iterator
				[Symbol.iterator]() {
					// Individual por Instancia
					let next = Math.ceil(this.from);
					let last = this.to;
					return {
						next() {
							// Só avança se não estiver no fim.
							return next <= last ? { value: next++ } : { done: true };
						},
						// Range Iteravel
						[Symbol.iterator]() {
							return this;
						},
					};
				}
			}
			return new Range(from, to);
		};
		// Comparardor de string LIKE
		static like = (strMenor, strMaior) => {
			let result = false;
			// Se utilizar match, não pode ter os reservados do regex.
			strMaior = mk.apenasNumerosLetras(strMaior).toLowerCase().trim();
			strMenor = mk.apenasNumerosLetras(strMenor).toLowerCase().trim();
			let rmMaior = strMaior.toLowerCase().trim();
			let rmMenor = strMenor.toLowerCase().trim();
			if (rmMaior.match(rmMenor)) {
				result = true;
			}
			// Internacionalizador de comparação... (Galês CH e DD e Latin ä))
			let likeMatcher = new Intl.Collator(undefined, {
				sensitivity: "base",
				ignorePunctuation: true,
			}).compare;
			if (likeMatcher(strMaior, strMenor) === 0) {
				result = true;
			}
			return result;
		};
		// Comparardor de string CONTEM
		static contem = (strMaior, strMenor) => {
			strMaior = mk.removeEspecias(strMaior).toLowerCase();
			strMenor = mk.removeEspecias(strMenor).toLowerCase();
			return (strMaior.includes(strMenor));
		};
		// Informando a Array ou o Objeto, itera sobre todas e executa a funcao, e retorna o total de propriedades iteradas.
		static allSubPropriedades = (OA, funcao = null, exceto = "object") => {
			let c = 0;
			for (let a in OA) {
				let target = OA[a];
				if (typeof target != exceto) {
					if (funcao) {
						funcao(target);
					}
				}
				c++;
				// Se o atual é objeto, itera internamente
				if (typeof target == "object") {
					c += mk.allSubPropriedades(target, funcao, exceto);
				}
			}
			return c;
		};
		// Verifica se ARRAY ou OBJETO e executa a função FUNC a cada objeto dentro de OA.
		static mkExecutaNoObj = (oa, func) => {
			if (Array.isArray(oa)) {
				for (let i = 0; i < oa.length; i++) {
					func(oa[i]);
				}
			}
			else {
				func(oa);
			}
			return oa;
		};
		// Converter (OBJ / ARRAY) Limpar Nulos e Vazios
		static mkLimparOA = (oa) => {
			// Trocar para arrow
			function mkLimparOA_Execute(o) {
				for (var propName in o) {
					if (o[propName] === null ||
						o[propName] === "") {
						delete o[propName];
					}
				}
				return o;
			}
			return mk.mkExecutaNoObj(oa, mkLimparOA_Execute);
		};
		// Gerar Objeto a partir de um Form Entries
		static mkGerarObjeto = (este) => {
			let form = este;
			if (typeof este != "object") {
				form = mk.Q(este);
			}
			let rObjeto = mk.mkLimparOA(Object.fromEntries(new FormData(form).entries()));
			mk.gc("Objeto Gerado: ");
			mk.l(rObjeto);
			mk.ge();
			return rObjeto;
		};
		static QSet = (query = "body", valor = null) => {
			let e = mk.Q(query);
			if (e) {
				if (valor != null) {
					if (e)
						e.value = valor;
				}
				else {
					let e = mk.Q(query);
					if (e)
						e.value = "";
				}
				return e;
			}
			else {
				return null;
			}
		};
		// Seta todos os query com os valores das propriedades informadas nos campos.
		// O nome da propriedade precisa ser compatível com o PROPNAME do query.
		static QSetAll = (query = "input[name='#PROP#']", o = null, comEvento = true) => {
			let eAfetados = [];
			if (o != null) {
				if (typeof o == "object" && !Array.isArray(o)) {
					for (let p in o) {
						let eDynamicQuery = mk.Q(query.replace("#PROP#", p));
						if (eDynamicQuery) {
							if (o[p]) {
								eDynamicQuery.value = o[p];
								if (comEvento) {
									eDynamicQuery.classList.add("atualizar");
								}
								else {
									eDynamicQuery.classList.add("atualizarSemEvento");
								}
								eAfetados.push(eDynamicQuery);
							}
						}
					}
				}
				else
					mk.w("QSetAll - Precisa receber um objeto: " + o);
			}
			else
				mk.w("QSetAll - Objeto não pode ser nulo: " + o);
			return eAfetados;
		};
		static Qon = (query = "body") => {
			return mk.aCadaElemento(query, (e) => {
				if (e instanceof HTMLButtonElement || e instanceof HTMLInputElement) {
					e.disabled = false;
				}
				e.classList.remove("disabled");
				e.removeAttribute("tabindex");
			});
		};
		static Qoff = (query = "body") => {
			return mk.aCadaElemento(query, (e) => {
				if (e instanceof HTMLButtonElement || e instanceof HTMLInputElement) {
					e.disabled = true;
				}
				e.classList.add("disabled");
				e.setAttribute("tabindex", "-1");
			});
		};
		static Qison = (query = "body") => {
			return mk.cadaExe(query, (e) => {
				let b = false;
				if (!e.classList.contains("disabled")) {
					b = true;
				}
				return b;
			});
		};
		static QverOn = (query = "body") => {
			return mk.aCadaElemento(query, (e) => {
				e?.classList.remove("oculto");
			});
		};
		static QverOff = (query = "body") => {
			return mk.aCadaElemento(query, (e) => {
				e?.classList.add("oculto");
			});
		};
		static QverToggle = (query = "body") => {
			return mk.aCadaElemento(query, (e) => {
				e?.classList.toggle("oculto");
			});
		};
		// Query: String, Element, [Element,Element]
		static aCadaElemento = (query, fn) => {
			if (typeof query == "string") {
				let retorno;
				let elementos = mk.QAll(query);
				if (elementos.length == 1)
					retorno = elementos[0];
				else
					retorno = elementos;
				elementos.forEach((e) => {
					fn(e);
				});
				return retorno;
			}
			else if (Array.isArray(query)) {
				query.forEach((e) => {
					fn(e);
				});
				return query;
			}
			else {
				let e = mk.Q(query);
				fn(e);
				return e;
			}
		};
		// Query: String, Element, [Element,Element]
		// Retorna uma array de resultados de cada execucao
		static cadaExe = (query, fn) => {
			let retorno = [];
			if (typeof query == "string") {
				let elementos = mk.QAll(query);
				elementos.forEach((e) => {
					retorno.push(fn(e));
				});
			}
			else if (Array.isArray(query)) {
				query.forEach((e) => {
					retorno.push(fn(e));
				});
			}
			else {
				let e = mk.Q(query);
				retorno.push(fn(e));
			}
			return retorno;
		};
		static QScrollTo = (query = "body") => {
			let temp = mk.Q(query);
			let distTopo = temp.offsetTop;
			window.scrollTo({
				top: distTopo,
				behavior: "smooth",
			});
			return temp;
		};
		static QdataGet = (query = "body", atributoNome) => {
			return mk.Q(query).getAttribute("data-" + atributoNome);
		};
		static QdataSet = (query = "body", atributoNome, atributoValor) => {
			return mk.Q(query).setAttribute("data-" + atributoNome, atributoValor);
		};
		static toggleSwitcher = (e) => {
			if (e.classList.contains("True")) {
				e.classList.remove("True");
				e.classList.add("False");
			}
			else {
				if (e.classList.contains("False")) {
					e.classList.remove("False");
					e.classList.add("True");
				}
			}
			return e;
		};
		// static QaSet = (query = "body", atributoNome, atributoValor) => {
		// 	return mk.Q(query).setAttribute(atributoNome, atributoValor);
		// };
		// static QaGet = (query = "body", atributoNome) => {
		// 	return mk.Q(query).getAttribute(atributoNome);
		// };
		static GetParam = (name = null) => {
			if (name != null) {
				return new URL(document.location.toString()).searchParams.get(name);
			}
			else {
				return new URL(document.location.toString()).searchParams;
			}
		};
		static isVisible = (e) => {
			return (e.offsetWidth > 0 || e.offsetHeight > 0 || e.getClientRects().length > 0);
		};
		// Ignora qualquer outro caracter além de Numeros e Letras formato ocidental
		static apenasNumerosLetras = (s = "") => {
			return s.replace(/(?![a-zA-Z0-9])./g, "");
		};
		// Ignora qualquer outro caracter além de Numeros
		static apenasNumeros = (s = "") => {
			return s.replace(/(?![0-9])./g, "");
		};
		// Ignora qualquer outro caracter além de Letras formato ocidental
		static apenasLetras = (s = "") => {
			return s.replace(/(?![a-zA-Z])./g, "");
		};
		static isFloat = (x) => {
			if (!isNaN(x)) {
				if (parseInt(x) != parseFloat(x)) {
					return true;
				}
			}
			return false;
		};
		// Remover parametros da URL
		static delUrlQuery = (url) => {
			let posIniQuery = url.indexOf("?");
			if (posIniQuery < 0)
				return url;
			return url.slice(0, posIniQuery);
		};
		// Funcção que recebe os dados de um arquivo e executa um Download deste dados.
		static gerarDownload = (conteudo, nomeArquivo = "Arquivo.zip") => {
			const fileUrl = URL.createObjectURL(conteudo);
			const link = document.createElement("a");
			link.href = fileUrl;
			link.download = nomeArquivo;
			link.click();
			URL.revokeObjectURL(fileUrl);
			return nomeArquivo;
		};
		// Get Server On
		static getServerOn = async (url = "/Login/GetServerOn") => {
			let pac = await mk.get.json({ url: url, quiet: true });
			// Vem nulo caso falhe
			if (pac?.retorno) {
				mk.detectedServerOn();
			}
			else {
				mk.detectedServerOff();
			}
		};
		static detectedServerOff = () => {
			if (mk.Q("body .offlineBlock") == null) {
				let divOfflineBlock = document.createElement("div");
				divOfflineBlock.className = "offlineBlock";
				let divOfflineBlockInterna = document.createElement("div");
				divOfflineBlockInterna.className = "text-center";
				divOfflineBlockInterna.innerHTML = "Servidor OFF-LINE";
				let buttonOfflineBlock = document.createElement("button");
				buttonOfflineBlock.setAttribute("type", "button");
				buttonOfflineBlock.setAttribute("onClick", "mk.detectedServerOn()");
				// let iOfflineBlock = document.createElement("i");
				// iOfflineBlock.className = "bi bi-x-lg";
				buttonOfflineBlock.innerHTML =
					"<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z'/></svg>";
				divOfflineBlock.appendChild(divOfflineBlockInterna);
				divOfflineBlock.appendChild(buttonOfflineBlock);
				document.body.appendChild(divOfflineBlock);
			}
			mk.Q("body .offlineBlock").classList.remove("oculto");
		};
		static detectedServerOn = () => {
			mk.Q("body .offlineBlock")?.classList?.add("oculto");
		};
		// Eventos HTML5
		// Bloqueio de teclas especificas onKeyDown
		static mkOnlyFloatKeys = (ev) => {
			// Input: UMA tecla QUALQUER
			//=> Metodo filtrar: Bloquear apenas estes
			//let proibido = "0123456789";
			//let isNegado = false;
			//for (var item in proibido) {
			//    (item == ev.key) ? isNegado = true : null;
			//}
			//=> Metodo filtrar: Liberar apenas estes
			let permitido = "0123456789,-";
			let isNegado = true;
			for (var i = 0; i < permitido.length; i++) {
				if (permitido[i] == ev.key.toString()) {
					//mk.l(permitido[i] + " == " + ev.key.toString());
					isNegado = false;
				}
			}
			//=> Teclas especiais
			ev.key == "ArrowLeft" ? (isNegado = false) : null; // Liberar Setinha pra Esquerda
			ev.key == "ArrowRight" ? (isNegado = false) : null; // Liberar Setinha pra Direita
			ev.key == "Backspace" ? (isNegado = false) : null; // Liberar Backspace
			ev.key == "Delete" ? (isNegado = false) : null; // Liberar Deletar
			ev.key == "Tab" ? (isNegado = false) : null; // Liberar Deletar
			if (isNegado) {
				ev.preventDefault();
				mk.w("Negado");
			}
		};
		// Bloqueios de eventos especificos (varios, exemplo: onContextMenu)
		static mkEventBlock = (ev) => {
			mk.w("Negado");
			ev.preventDefault();
		};
		// Imprimir e Exportar de ListaPrecos
		static mkTrocaPontoPorVirgula = (query) => {
			mk.QAll(query).forEach((e) => {
				e.innerHTML = e.innerHTML.replaceAll(".", ",");
			});
		};
		// Seleciona texto do elemento
		static mkSelecionarInner = (e) => {
			if (window.getSelection) {
				const selection = window.getSelection();
				const range = document.createRange();
				range.selectNodeContents(e);
				selection?.removeAllRanges();
				selection?.addRange(range);
			}
		};
		static mkInputFormatarValor = (e) => {
			// 123,45 (2 casas pos conversao float)
			e.value = mk.mkDuasCasas(mk.mkFloat(e.value));
		};
		static mkMedia = (menor, maior) => {
			return mk.mkDuasCasas((mk.mkFloat(menor) + mk.mkFloat(maior)) / 2);
		};
		static mkFloat = (num) => {
			let ret;
			if (typeof num != "number") {
				if (num)
					ret = parseFloat(num.toString().replaceAll(".", "").replaceAll(",", "."));
				else
					ret = 0;
			}
			else {
				ret = num;
			}
			if (isNaN(ret)) {
				ret = 0;
			}
			return ret;
		};
		static mkDuasCasas = (num) => {
			return mk.mkFloat(num).toFixed(2).replaceAll(".", ","); // 2000,00
			//        .toLocaleString('pt-br', { minimumFractionDigits: 2, maximumFractionDigits: 2 }); // 2.000,00
		};
		// Funcao para formatar número para exibição
		static mkNCasas = (num, nCasas = 2) => {
			return mk.mkFloat(num).toFixed(nCasas).replaceAll(".", ","); // 2000,?
		};
		static mkEmReais = (num) => {
			return mk.mkFloat(num).toLocaleString("pt-br", {
				style: "currency",
				currency: "BRL",
			}); // R$ 12.123,45
		};
		// String qualquer para B64
		static encod = (texto = "") => {
			return btoa(encodeURIComponent(texto));
		};
		// B64 para String
		static decod = (texto = "") => {
			return decodeURIComponent(atob(texto));
		};
		static mkBase64 = (arquivo, tagImg, tagHidden) => {
			// Verificar se esta nulo
			let leitor = new FileReader();
			leitor.onload = () => {
				mk.Q(tagImg).src = leitor.result;
				mk.Q(tagHidden).value = leitor.result;
			};
			leitor.readAsDataURL(arquivo);
		};
		static ler = async (arq, p) => {
			return new Promise((r) => {
				let leitor = new FileReader();
				leitor.onprogress = (ev) => {
					if (ev.lengthComputable) {
						let carga = ev.loaded / ev.total;
						if (carga <= 1) {
							if (p)
								p(carga);
						}
					}
				};
				leitor.onload = (ev) => {
					arq.b64 = ev.target?.result;
					r(arq);
				};
				leitor.onerror = () => {
					console.error("Erro ao ler arquivo: " + arq);
				};
				if (arq) {
					if (arq.name != "") {
						leitor.readAsDataURL(arq);
					}
					else {
						mk.l("F: Sem nome de arquivo.", arq);
						r(null);
					}
				}
				else {
					mk.l("F: Arquivo Nulo.", arq);
					r(null);
				}
			});
		};
		static clonar = (i) => {
			return JSON.parse(JSON.stringify(i));
		};
		static getModelo = (array) => {
			let chaves = new Set();
			array.forEach((o) => {
				Object.keys(o).forEach((p) => {
					chaves.add(p);
				});
			});
			let modelo = {};
			chaves.forEach((k) => {
				modelo[k] = [];
				array.forEach((o) => {
					let tipo = typeof o[k];
					if (modelo[k].indexOf(tipo) < 0)
						modelo[k].push(tipo);
				});
			});
			return modelo;
		};
		static mkMerge = (o, ...fontes) => {
			for (let fonte of fontes) {
				for (let k of Object.keys(fonte)) {
					if (!(k in o)) {
						o[k] = fonte[k];
					}
				}
			}
			return o;
		};
		// Sobe os elementos até encontrar o form pertencente a este elemento. (Se limita ao BODY)
		static getFormFrom = (e) => {
			let eForm = e;
			while (eForm.tagName != "FORM") {
				eForm = eForm.parentElement;
				if (eForm.tagName == "BODY") {
					console.error("Não foi possível encontrar o elemento FORM na busca getFormFrom()");
					break;
				}
			}
			return eForm;
		};
		static getTr = (e) => {
			let eTr = e;
			while (eTr.tagName != "TR") {
				eTr = eTr.parentElement;
				if (eTr.tagName == "BODY") {
					console.error("Não foi possível encontrar o elemento TR na busca getTr()");
					eTr = null;
					break;
				}
			}
			return eTr;
		};
		// Sobe elementos pais até encontrar este elemento
		static getETag = (e, tag) => {
			let eTr = e;
			while (eTr.tagName != tag) {
				eTr = eTr.parentElement;
				if (eTr.tagName == "BODY") {
					console.error("Não foi possível encontrar o elemento " + tag + " na busca getETag()");
					eTr = null;
					break;
				}
			}
			return eTr;
		};
		// Sobe elementos pais até encontrar esta classe
		static getEClass = (e, classe) => {
			let eClass = e;
			while (!eClass.classList.contains(classe)) {
				eClass = eClass.parentElement;
				if (eClass == null) {
					console.error("Não foi possível encontrar o elemento com esta classe. getEClass.", classe);
					eClass = null;
					break;
				}
			}
			return eClass;
		};
		// Retorna uma array utilizando um template do que deve ser preenchido.
		static encheArray = (arrTemplate, inicio = 1, total) => {
			let novaArray = [];
			if (Array.isArray(arrTemplate)) {
				if (arrTemplate.length > 0) {
					if (arrTemplate.length < inicio) {
						console.error("O arrTemplate tem menos itens do que o informado para o inicio");
						return novaArray;
					}
				}
				else {
					console.error("Função encheArray precisa receber ao menos 1 item em arrTemplate.");
					return novaArray;
				}
			}
			else {
				console.error("Função encheArray precisa receber uma array com dados em arrTemplate.");
				return novaArray;
			}
			if (inicio <= 0) {
				console.error("O inicio precisa ser maior que zero.");
				return novaArray;
			}
			if (total == null)
				total = arrTemplate.length;
			let proximo = inicio;
			for (let c = 0; c < total; c++) {
				novaArray.push(arrTemplate[proximo - 1]);
				proximo++;
				if (proximo > arrTemplate.length) {
					proximo = 1;
				}
			}
			return novaArray;
		};
		// Retorna uma array dos últimos
		static encheArrayUltimos = (arrTemplate, fim = 1, total) => {
			let novaArray = [];
			if (Array.isArray(arrTemplate)) {
				if (arrTemplate.length > 0) {
					if (arrTemplate.length < fim) {
						console.error("O arrTemplate tem menos itens do que o informado para o fim.");
						return novaArray;
					}
				}
				else {
					console.error("Função encheArrayUltimos precisa receber ao menos 1 item em arrTemplate.");
					return novaArray;
				}
			}
			else {
				console.error("Função encheArrayUltimos precisa receber uma array com dados em arrTemplate.");
				return novaArray;
			}
			if (fim <= 0) {
				console.error("O fim precisa ser maior que zero.");
				return novaArray;
			}
			if (total == null)
				total = arrTemplate.length;
			let anterior = fim;
			for (let c = total; c > 0; c--) {
				novaArray = [arrTemplate[anterior - 1], ...novaArray];
				anterior--;
				if (anterior <= 0) {
					anterior = arrTemplate.length;
				}
			}
			return novaArray;
		};
		// YYYY-MM-DD
		static isData = (i) => {
			return mk.util.data[1].test(i);
		};
		// Retorna Milisegundos da data no formato Javascript
		static getMs = (dataYYYYMMDD = null) => {
			if (dataYYYYMMDD != null) {
				let dataCortada = dataYYYYMMDD.split("-");
				let oDia = Number(dataCortada[2]);
				let oMes = Number(dataCortada[1]) - 1;
				let oAno = Number(dataCortada[0]);
				return new Date(oAno, oMes, oDia).getTime();
			}
			else
				return new Date().getTime();
		};
		// Retorna Data do cliente de Hoje em:  DD/MM/YYYY
		static hojeMkData = () => {
			return new Date(mk.getMs()).toLocaleDateString();
		};
		static hojeMkHora = () => {
			return new Date(Number(mk.getMs())).toLocaleTimeString();
		};
		// Retorna a data de Hoje no formato: DD/MM/YYYY
		static hoje = () => {
			let mkFullData = mk.hojeMkData() + " " + mk.hojeMkHora();
			return mkFullData;
		};
		// Retorna Data do cliente de Hoje em:  YYYY-MM-DD
		static getFullData = (ms = null) => {
			if (ms != null)
				return (new Date(ms).getFullYear() +
					"-" +
					(new Date(ms).getMonth() + 1) +
					"-" +
					new Date(ms).getDate());
			else
				return (new Date().getFullYear() +
					"-" +
					(new Date().getMonth() + 1) +
					"-" +
					new Date().getDate());
		};
		static getDia = (ms = null) => {
			if (ms != null)
				return Number(mk.getFullData(ms).split("-")[2]);
			else
				return Number(mk.getFullData().split("-")[2]);
		};
		static getMes = (ms = null) => {
			if (ms != null)
				return Number(mk.getFullData(ms).split("-")[1]);
			else
				return Number(mk.getFullData().split("-")[1]);
		};
		static getAno = (ms = null) => {
			if (ms != null)
				return Number(mk.getFullData(ms).split("-")[0]);
			else
				return Number(mk.getFullData().split("-")[0]);
		};
		static getTempoDiferenca = (msOld, msNew = null) => {
			let dias = mk.getDiasDiferenca(msOld, msNew);
			if (dias < 0) {
				dias = dias * -1;
			}
			let strTempo = "";
			if (dias > 30) {
				if (dias < 60) {
					strTempo = "1 mês";
				}
				else {
					if (dias > 365) {
						let anos = Math.floor(dias / 365);
						let diasRestoAno = dias % 365;
						if (anos < 2) {
							strTempo += anos + " ano ";
						}
						else {
							strTempo += anos + " anos ";
						}
						if (diasRestoAno > 30) {
							if (diasRestoAno < 60) {
								strTempo += "1 mês";
							}
							else {
								strTempo += Math.floor(diasRestoAno / 30) + " meses";
							}
						}
					}
					else {
						strTempo = Math.floor(dias / 30) + " meses";
					}
				}
			}
			else {
				if (dias < 1) {
					strTempo = "menos de 1 dia";
				}
				else {
					strTempo = dias + " dias";
				}
			}
			return strTempo;
		};
		static getDiasDiferenca = (msOld, msNew = null) => {
			if (msNew == null)
				msNew = mk.getMs();
			return mk.transMsEmDias(msNew - msOld);
		};
		// Para transformar uma diferenca de datas em Mes ou Ano,
		// precisa de auxilio de um calendário,
		// pois os dias não são sempre 24 horas.
		// Ao comparar meses de diferenca,
		// ocorrerá um erro na conta quando houver meses com 31 dias
		// E anos bissexto geram erros nos meses de fevereiro sem um calendario
		static transMsEmSegundos = (ms) => {
			return Math.trunc(ms / 1000); // 1000 ms == 1s
		};
		static transMsEmMinutos = (ms) => {
			return Math.trunc(ms / 60000); // 1000 * 60
		};
		static transMsEmHoras = (ms) => {
			return Math.trunc(ms / 3600000); // 1000 * 3600
		};
		static transMsEmDias = (ms) => {
			// 1000 * 3600 * 24 Considerando todo dia tiver 24 horas (~23h 56m 4.1s)
			// (360º translacao / 86400000) = ~4.1
			// Então o erro de 1 dia ocorre 1x ao ano (Dia represeta 1436min).
			return Math.trunc(ms / 86400000);
		};
		static transSegundosEmMs = (s) => {
			return s * 1000;
		};
		static transMinutosEmMs = (m) => {
			return m * 60000;
		};
		static transHorasEmMs = (h) => {
			return h * 3600000;
		};
		static transDiasEmMs = (d) => {
			return d * 86400000;
		};
		// Injeção de elementos
		static mkGeraElemento(e, nomeElemento = "script") {
			// Cria Elemento
			let elemento = document.createElement(nomeElemento);
			// Popular Elemento
			elemento.text = e.innerHTML;
			// Set Atributos
			let i = -1, attrs = e.attributes, attr;
			while (++i < attrs.length) {
				elemento.setAttribute((attr = attrs[i]).name, attr.value);
			}
			// Retorna Elemento
			return elemento;
		}
		// Função Recursiva que substitui node de Script por elemento de Script
		static mkNodeToScript(node) {
			// Apenas Scripts
			if (node.tagName === "SCRIPT") {
				node.parentNode.replaceChild(mk.mkGeraElemento(node, "script"), node);
			}
			else {
				// Recursividade sobre filhos
				var i = -1, children = node.childNodes;
				while (++i < children.length) {
					mk.mkNodeToScript(children[i]);
				}
			}
			return node;
		}
		// Calculo de frequencia
		// Conta o total do que tem dentro da array e retorna a frequencia destes;
		static frequencia = (array) => {
			let f = {};
			for (let e of array) {
				f[e] ? f[e]++ : (f[e] = 1);
			}
			return f;
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			Conversores									\\
		//___________________________________\\
		// Converter de YYYY-MM-DD para DD/MM/YYYY
		static mkYYYYMMDDtoDDMMYYYY = (dataYYYYMMDD) => {
			let arrayData = dataYYYYMMDD.split("-");
			let stringRetorno = "";
			if (arrayData.length >= 3) {
				// Tenta evitar bug de conversao
				stringRetorno = arrayData[2] + "/" + arrayData[1] + "/" + arrayData[0];
			}
			else {
				stringRetorno = dataYYYYMMDD;
			}
			return stringRetorno;
		};
		// Converter (OBJ / ARRAY) Formato Booleano em Sim/Não
		static mkFormatarDataOA = (oa) => {
			function mkFormatarDataOA_Execute(o) {
				let busca = new RegExp("^[0-2][0-9]{3}[-][0-1][0-9][-][0-3][0-9]$"); // Entre 0000-00-00 a 2999-19-39
				for (var propName in o) {
					if (busca.test(o[propName])) {
						o[propName] = mk.mkYYYYMMDDtoDDMMYYYY(o[propName]);
					}
				}
				return o;
			}
			return mk.mkExecutaNoObj(oa, mkFormatarDataOA_Execute);
		};
		// Converter (OBJ / ARRAY) Formato Booleano em Sim/Não
		static mkBoolToSimNaoOA = (oa) => {
			function mkBoolToSimNaoOA_Execute(o) {
				for (var propName in o) {
					if (o[propName].toString().toLowerCase() === "true" ||
						o[propName] === true) {
						o[propName] = "Sim";
					}
					if (o[propName].toString().toLowerCase() === "false" ||
						o[propName] === false) {
						o[propName] = "N&atilde;o";
					}
				}
				return o;
			}
			return mk.mkExecutaNoObj(oa, mkBoolToSimNaoOA_Execute);
		};
		// Converter (OBJ / ARRAY) Formatar para normalizar com a exibicao ao usuario.
		static mkFormatarOA = (oa) => {
			return mk.mkBoolToSimNaoOA(mk.mkFormatarDataOA(mk.mkLimparOA(oa)));
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			Carregador									\\
		//___________________________________\\
		static CarregarON = (nomeDoRequest = "") => {
			if (mk.Q("body .CarregadorMkBlock") == null) {
				let divCarregadorMkBlock = document.createElement("div");
				divCarregadorMkBlock.className = "CarregadorMkBlock";
				let divCarregadorMk = document.createElement("div");
				divCarregadorMk.className = "CarregadorMk";
				let buttonCarregadorMkTopoDireito = document.createElement("button");
				buttonCarregadorMkTopoDireito.className = "CarregadorMkTopoDireito";
				buttonCarregadorMkTopoDireito.setAttribute("type", "button");
				buttonCarregadorMkTopoDireito.setAttribute("onClick", "mk.CarregarOFF()");
				buttonCarregadorMkTopoDireito.innerHTML =
					"<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z'/></svg>";
				divCarregadorMkBlock.appendChild(divCarregadorMk);
				divCarregadorMkBlock.appendChild(buttonCarregadorMkTopoDireito);
				document.body.appendChild(divCarregadorMkBlock);
			}
			mk.Q("body .CarregadorMkBlock").classList.remove("oculto");
			mk.Q("body").classList.add("CarregadorMkSemScrollY");
		};
		static CarregarOFF = (nomeDoRequest = "") => {
			if (mk.Q("body .CarregadorMkBlock") != null) {
				mk.Q("body .CarregadorMkBlock").classList.add("oculto");
			}
			mk.Q("body").classList.remove("CarregadorMkSemScrollY");
		};
		static CarregarHtml = (estilo = "", classe = "relative") => {
			return `<div class="CarregadorMk ${classe}" style="${estilo}"></div>`;
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			REQUEST											\\
		//___________________________________\\
		// Formas pre formatadas de chamar o Request de forma simples.
		// mk.get.json({ url:"/GetList", done: (c)=>{console.log("done:",c)}})
		static get = {
			json: async (config) => {
				if (typeof config != "object")
					config = { url: config };
				config.metodo = mk.t.G;
				config.tipo = mk.t.J;
				return await mk.request(config);
			},
			html: async (config) => {
				if (typeof config != "object")
					config = { url: config };
				config.metodo = mk.t.G;
				config.tipo = mk.t.H;
				let retorno = await mk.request(config);
				return retorno;
			}
		};
		static post = {
			json: async (config, json) => {
				if (typeof config != "object")
					config = { url: config };
				config.metodo = mk.t.P;
				config.tipo = mk.t.J;
				config.dados = json;
				let retorno = await mk.request(config);
				return retorno;
			},
			html: async (config, text) => {
				if (typeof config != "object")
					config = { url: config };
				config.metodo = mk.t.P;
				config.tipo = mk.t.H;
				config.dados = text;
				let retorno = await mk.request(config);
				return retorno;
			},
			form: async (config, formdata) => {
				if (typeof config != "object")
					config = { url: config };
				config.metodo = mk.t.P;
				config.tipo = mk.t.F;
				config.dados = formdata;
				let retorno = await mk.request(config);
				return retorno;
			}
		};
		/** REQUEST
		 * Se Utilizar o await, o config enviado retorna com o resultado e o pacote
		 * Se definir o done e/ou o error no config, será executado como callback também.
		 * @param config  Estes são as propriedades em uso do config:
		 * {
		 * 	url: "www.google.com",
		 * 	metoto: "GET",
		 * 	tipo: "application/json",
		 * 	dados: ["a",1],
		 * 	headers: new Headers(),
		 * 	quiet: false,
		 * 	dev: false,
		 * 	carregador: false,
		 * 	done: (c)=>{mk.l("Deu Boa? ",c.pacote.ok)},
		 * 	error: (c)=>{mk.l("Deu Boa? ",c.pacote.ok)},
		 *  //pacote: É populado com os dados do pacote.
		 *  //retorno: É populado com os dados retornados.
		 * }
		 * @returns Sempre retorna o config preenchido (utilizar await para capturar o resultado)
		 */
		static request = async (config) => {
			// CONFIG ! Necessário
			if (typeof config != "object") {
				this.w("É necessário informar o objeto de configuração com a URL.");
				return { url: null, retorno: null }; // Não há config, Mas pra retornar sempre o config
			}
			// URL ! Necessário
			if (!config?.url) {
				this.w("Necessário informar uma URL nos requests.");
				return { url: config?.url, retorno: null };
			}
			// GET ? POST, PUT, DELETE
			if (!config?.metodo) {
				this.w("Nenhum método informado. Avançando com GET");
				config.metodo = "GET";
			}
			else {
				if (config.metodo == "POST" && config.dados == null) { // Todo POST requer dados a serem enviados.
					this.w("Método POST, mas SEM DADOS informados. Enviando string vazia ''.");
					config.dados = "";
				}
			}
			// Name e Timer Start
			let nomeRequest = config.metodo + ": " + config.url;
			mk.ct("Request: " + nomeRequest);
			// JSON / FORM / *
			if (!config?.tipo) {
				this.w("Nenhum tipo de dado informado. Avançando com " + mk.t.J);
				config.tipo = mk.t.J;
			}
			if (!config?.headers) {
				config.headers = new Headers();
				// CONTENT TYPE
				if (config.tipo == mk.t.J) {
					config.headers.append("Content-Type", config.tipo);
				}
				// TOKEN
				let aft = document.getElementsByName("__RequestVerificationToken")[0]?.value;
				config.headers.append("MKANTI-FORGERY-TOKEN", aft || "");
			}
			if (!config.quiet)
				config.quiet = false;
			// TIPO DE ENVIO
			config.json = JSON.stringify(config.dados);
			if (config.metodo != mk.t.G) {
				if (config.tipo == mk.t.J) {
					config.body = config.json;
				}
				else if (config.tipo == mk.t.F) {
					config.body = config.dados;
				}
			}
			// config.dev = true;
			// INFO CONSOLE
			if (!config.quiet) {
				mk.gc(nomeRequest);
				if (config.dev) {
					mk.l("Header: ", Object.fromEntries(config.headers.entries()));
					mk.l("Config: ", config);
				}
				if (config.metodo == mk.t.P) {
					mk.l("DADOS: ", config.dados);
					mk.gc("JSON: ");
					mk.l(config.json);
					mk.ge();
					if (typeof config.dados == "object") {
						if (config.dados.entries != null) {
							mk.gc("FORM OBJECT");
							mk.l(Object.fromEntries(config.dados.entries()));
							mk.ge();
						}
					}
				}
				mk.ge(); // Fim do metodo
			}
			// Inicia o carregador 
			if (config.carregador) {
				this.CarregarON(nomeRequest);
			}
			// O EXECUTOR		
			config.retorno = null;
			config.statusCode = "SEM CONEXÃO";
			try {
				config.pacote = await fetch(config.url, {
					method: config.metodo,
					headers: config.headers,
					body: config.body,
				});
				if (!config.pacote.ok) {
					config.conectou = false;
					config.statusCode = config.pacote.status;
					// FALHA (NÂO 200)
					mk.gc("HTTP RETURNO: " + config.pacote.status + " " + config.pacote.statusText);
					mk.l(await config.pacote.text()); // Exibir o erro no console;
					mk.ge();
				}
				else {
					config.conectou = true;
					config.statusCode = config.pacote.status;
					// 200 DONE (Retorna baseado no tipo de envio)
					if (config.tipo == mk.t.J) {
						config.retorno = await config.pacote.json();
					}
					else if (config.tipo == mk.t.H) {
						config.retorno = await config.pacote.text();
					}
					else if (config.tipo == mk.t.B) {
						config.retorno = await config.pacote.blob();
					}
					else if (config.tipo == mk.t.F) {
						config.retorno = await config.pacote.json();
					}
					if (!config.quiet) {
						mk.gc("Retorno " + config.pacote.status +
							" (" + config.metodo + "): " +
							config.url + " (" + config.tipo + ")");
					}
					mk.cte("Request: " + nomeRequest, config.quiet);
					if (!config.quiet) {
						mk.l(config.retorno);
						mk.ge();
					}
					if (config.done) {
						config.done(config);
					}
				}
			}
			catch (error) {
				// Caso Conection_Refused, Não tem código de erro. Então cai aqui.
				config.conectou = false;
				config.catch = error;
			}
			// Aqui tem Status code se o erro foi no servidor, Mas não tem se o servidor não estiver online.
			if (!config.conectou) {
				mk.gc("(" + config.statusCode + ") HTTP ERRO:");
				// Se bateu no catch, expoem trace error do JS
				if (config.catch && !config.quiet) {
					mk.l("Config: " + config);
					console.error("Erro: ", config.catch);
				}
				// Executa funcao de erro externa.
				if (config.error) {
					config.error(config);
				}
				mk.ge();
			}
			// Finaliza o carregador 
			if (config.carregador) {
				this.CarregarOFF(nomeRequest);
			}
			// Sempre retorna o config
			return config;
		};
		// Método principal de chamada Http. tanto GET quanto POST
		static http = async (url, metodo = mk.t.G, tipo = mk.t.J, dados = null, carregador = false) => {
			const mkaft = document.getElementsByName("__RequestVerificationToken")[0];
			let body = null;
			let headers = new Headers();
			headers.append("MKANTI-FORGERY-TOKEN", mkaft ? mkaft.value : "");
			if (dados != null) {
				if (tipo == mk.t.J) {
					headers.append("Content-Type", tipo);
					body = JSON.stringify(dados);
				}
				else if (tipo == mk.t.F) {
					body = dados;
				}
			}
			let pacote = {
				method: metodo,
				headers: headers,
				body: body,
			};
			if (carregador) {
				this.CarregarON();
			}
			// INFO DEV
			mk.gc(pacote.method + ": " + url);
			mk.ct("Request: " + url);
			if (mk.debug == 1) {
				mk.gc(">> Cabecalho do pacote");
				mk.l(Object.fromEntries(headers.entries()));
				mk.gc(">> Pacote full");
				mk.l(pacote);
				mk.ge();
				mk.ge();
			}
			if (metodo == mk.t.P) {
				mk.gc(">> Objeto Enviado (Body)");
				console.group(">> Dados transmitidos");
				mk.l(dados);
				mk.ge();
				mk.gc(">> JSON String");
				mk.l(body?.toString());
				mk.ge();
				if (typeof dados == "object") {
					if (dados.entries != null) {
						mk.gc(">>> Form Object");
						mk.l(Object.fromEntries(dados.entries()));
						mk.ge();
					}
				}
				mk.ge();
			}
			mk.ge();
			// EXECUCAO
			let corpo = null;
			try {
				const pacoteHttp = await fetch(url, pacote);
				if (!pacoteHttp.ok) {
					mk.gc("HTTP RETURNO: " + pacoteHttp.status + " " + pacoteHttp.statusText);
					console.error("HTTP RETURNO: Não retornou 200.");
					mk.l(await pacoteHttp.text()); // Exibir o erro no console;
					mk.ge();
					if (carregador) {
						this.CarregarOFF();
					}
					return null;
				}
				if (tipo == mk.t.J) {
					corpo = await pacoteHttp.json();
				}
				else if (tipo == mk.t.H) {
					corpo = await pacoteHttp.text();
				}
				else if (tipo == mk.t.B) {
					corpo = await pacoteHttp.blob();
				}
				else if (tipo == mk.t.F) {
					corpo = await pacoteHttp.json();
				}
				if (carregador) {
					this.CarregarOFF();
				}
				mk.gc("Retorno (" + pacoteHttp.status +
					" " + pacote.method +
					" " +
					tipo.toUpperCase().split("/")[1] +
					"): " +
					url);
				mk.cte("Request: " + url);
				mk.l(corpo);
				mk.ge();
				//if (sucesso != null) sucesso(corpo);
			}
			catch (error) {
				if (carregador) {
					this.CarregarOFF();
				}
				if (error) {
					mk.gc("HTTP ERRO: ");
					console.error("Erro: ", error);
					mk.ge();
				}
				return null;
			}
			return corpo;
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			LISTAGEM										\\
		//___________________________________\\
		// GET OBJ - Retorna O objeto de uma Lista
		static getObjetoFromId = (nomeKey, valorKey, listaDados) => {
			let temp = null;
			if (Array.isArray(listaDados)) {
				listaDados.forEach((o) => {
					if (o[nomeKey] == valorKey) {
						temp = o;
					}
				});
			}
			return temp;
		};
		// GET OBJ - Retorna O objeto de uma Lista
		static setObjetoFromId = (nomeKey, valorKey, itemModificado, listaDados) => {
			if (Array.isArray(listaDados)) {
				listaDados.forEach((o) => {
					if (o[nomeKey] == valorKey) {
						o = itemModificado;
					}
				});
			}
			return listaDados;
		};
		// DEL OBJ - Retorna a lista sem o objeto informado
		static delObjetoFromId = (nomeKey, valorKey, listaDados) => {
			let temp = [];
			if (Array.isArray(listaDados)) {
				listaDados.forEach((o) => {
					if (o[nomeKey] != valorKey) {
						temp.push(o);
					}
				});
			}
			else {
				temp = listaDados;
			}
			return temp;
		};
		// Metodo que eh executado ao completar a exibicao (PODE SOBREESCREVER NA VIEW)
		static aoCompletarExibicao = () => { };
		// Metodo que eh executado antes de exibir (PODE SOBREESCREVER NA VIEW)
		static antesDePopularTabela = () => { };
		// Torna ativo o botao que se refere ao paginationAtual
		static ativaPaginaAtual = () => {
			mk.QAll(".paginate_button").forEach((item) => {
				item.classList.remove("active");
			});
			mk.QAll(".paginate_button .page-link").forEach((item) => {
				if (this.paginationAtual == Number(item.innerHTML)) {
					item.parentElement?.classList.add("active");
				}
			});
		}; // Desativa e ativa botao correto
		/**
		 * FullFiltroFull - processoFiltragem
		 * Executa a redução da listagem basedo no objFiltro.
		 * Usando modificaFiltro(), pode-se filtrar o objeto da lista também.
		 */
		static processoFiltragem = (aTotal, objFiltro, inst) => {
			let aFiltrada = [];
			if (Array.isArray(aTotal)) {
				let temp = [];
				aTotal.forEach((o) => {
					let podeExibir = inst.modicaFiltro(o); // true
					if (typeof podeExibir != "boolean") {
						podeExibir = true;
						mk.w("modicaFiltro() precisa retornar boolean");
					}
					for (let propFiltro in objFiltro) {
						// Faz-se o cruzamento dos dados, quando encontrar a prorpiedade no outro objeto, seta pra executar o filtro.
						let m = null;
						if (o[propFiltro] != null) {
							m = o[propFiltro]; // m representa o dado do item
						}
						if (propFiltro.includes(".")) {
							m = mk.getV(propFiltro, o); // m representa o dado do item
							//this.l("NoFIltro: ", objFiltro[propFiltro].conteudo.toString().toLowerCase(), " > DadoItem: ", m)
						}
						//this.l("objFiltro[propFiltro]: ", objFiltro[propFiltro])
						// Cada Propriedade de Cada Item da Array
						if (m != null) {
							// Cruzar referencia com objFiltro e se so avancar se realmente for um objeto
							let k = objFiltro[propFiltro]; // k representa a config do filtro para essa propriedade
							if (k.formato === "string") {
								k.conteudo = k.conteudo.toString().toLowerCase();
								if (!mk.contem(m, k.conteudo)) {
									podeExibir = false;
								}
							}
							else if (k.formato === "stringNumerosVirgula") {
								// Filtro por numero exado. Provavelmente sejam duas arrays (MultiSelect), O filtro precisa encontrar tudo no objeto.
								let filtroInvertido = false;
								if (this.isJson(k.conteudo)) {
									let arrayM = m.toString().split(","); // String de Numeros em Array de Strings
									let mayBeArrayK = JSON.parse(k.conteudo); // << No objFiltro
									if (Array.isArray(mayBeArrayK)) {
										mayBeArrayK.forEach((numeroK) => {
											// A cada numero encontrado pos split na string do item verificado
											filtroInvertido = arrayM.some((numeroM) => {
												return Number(numeroM) == Number(numeroK);
											});
										});
									}
									else {
										filtroInvertido = arrayM.some((numeroM) => {
											return Number(numeroM) == Number(mayBeArrayK);
										});
									}
									if (!filtroInvertido) {
										podeExibir = false;
									}
								}
								else
									mk.w("Não é um JSON");
							}
							else if (k.formato === "number") {
								// Filtro por numero exado. Apenas exibe este exato numero.
								// Ignorar filtro com 0
								if (Number(m) !== Number(k.conteudo) &&
									Number(k.conteudo) !== 0) {
									podeExibir = false;
								}
							}
							else if (k.formato === "date") {
								// Filtro por Data (Gera milissegundos e faz comparacao)
								let dateM = new Date(m).getTime();
								let dateK = new Date(k.conteudo).getTime();
								if (k.operador === ">=") {
									// MAIOR OU IGUAL
									if (!(dateM >= dateK)) {
										podeExibir = false;
									}
								}
								else if (k.operador === "<=") {
									// MENOR OU IGUAL
									if (!(dateM <= dateK)) {
										podeExibir = false;
									}
								}
								else if (k.operador === ">") {
									// MAIOR
									if (!(dateM > dateK)) {
										podeExibir = false;
									}
								}
								else if (k.operador === "<") {
									// MENOR
									if (!(dateM < dateK)) {
										podeExibir = false;
									}
								}
								else {
									// IGUAL ou nao informado
									if (!(dateM == dateK)) {
										podeExibir = false;
									}
								}
							}
						}
						else {
							if (propFiltro != "mkFullFiltro") {
								podeExibir = false;
							}
						}
					}
					if (podeExibir) {
						// Verificara todas prop, logica da adicao por caracteristica buscada
						if (objFiltro["mkFullFiltro"]) {
							// Se houver pesquisa generica no filtro
							let k = objFiltro["mkFullFiltro"]["conteudo"]
								.toString()
								.toLowerCase(); // k = Dado que estamos procurando
							podeExibir = false; // Inverter para verificar se alguma prop do item possui a caracteristica
							mk.allSubPropriedades(o, (v) => {
								if (v != null) {
									// <= Nao pode tentar filtrar em itens nulos
									v = v.toString().toLowerCase();
									if (v.match(k)) {
										podeExibir = true;
									}
								}
							});
						}
					}
					if (podeExibir) {
						temp.push(o);
					}
				});
				aFiltrada = temp;
			}
			else {
				aFiltrada = [];
			}
			return aFiltrada;
		};
		// Metodo que eh executado sempre que um dado for recebido. (PODE SOBREESCREVER NA VIEW)
		static aoReceberDados = (data) => {
			return data;
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			ORDER LIST									\\
		//___________________________________\\
		// Está sendo utilizado no GetList. Verificar como utilizar o ordenar no getlist para deletar este aqui.
		static ordenamento = (a, por, dir) => {
			a.sort((oA, oB) => {
				let a = oA[por];
				let b = oB[por];
				if (typeof a == "string")
					a = a.toLowerCase();
				if (typeof b == "string")
					b = b.toLowerCase();
				if (a !== b) {
					if (a > b)
						return 1;
					if (a < b)
						return -1;
				}
				return -1;
			});
			if (dir == 1) {
				// Direção Reversa (Ver setDirSort)
				a = a.reverse();
			}
			return a;
		};
		// Possibilidade de inverter a lista (Tentar deixar esse padrao)
		// Essa funcção deveria ser da instancia atual para recever os atributos da instancia por padrao
		static ordenar = (array, nomeProp, reverse) => {
			array.sort((oA, oB) => {
				let a = oA[nomeProp];
				let b = oB[nomeProp];
				if (typeof a == "string")
					a = a.toLowerCase();
				if (typeof b == "string")
					b = b.toLowerCase();
				if (a !== b) {
					if (a > b)
						return 1;
					if (a < b)
						return -1;
				}
				return -1;
			});
			this.contaOrdena++;
			if (reverse == true) {
				array = array.reverse();
			}
			else if (reverse == 2) {
				// toogle
				if (this.contaOrdena % 2 == 0) {
					array = array.reverse();
				}
			}
			return array;
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			VALIDADOR										\\
		//___________________________________\\
		// Efeito de terremoto em campos com erros no formulario informado
		static TerremotoErros = (form) => {
			mk.QAll(form + " input.input-validation-error").forEach((e) => {
				e.nextElementSibling?.classList.add("mkTerremoto");
				setTimeout(() => {
					e.nextElementSibling?.classList.remove("mkTerremoto");
				}, 500);
			});
		};
		// Funcao tipo isPendente para validacao para mkValida. Aqui valida Pendente apenas.
		static mkAindaPendente = (form) => {
			let temPendencia = false;
			mk.QAll(form + " input").forEach((e) => {
				if (mk.isVisible(e)) {
					if (e.classList.contains("pending")) {
						temPendencia = true;
						e.classList.remove("valid");
						e.classList.add("input-validation-error");
					}
				}
			});
			return temPendencia;
		};
		// Limpar Validates adicionados anteriormente e fazer novamente com os atuais.
		static FixValidate = (form) => {
			// Parse + Remove
			$.validator.unobtrusive.parse($(form).removeData("validator").removeData("unobtrusiveValidation"));
			// Para modificar campos setados:
			// $(form).data('unobtrusiveValidation').options.rules
		};
		// $ Unobtrusive: id do form
		static verificarCampos = (form) => {
			// Fast Parse Call all forms
			$.validator.unobtrusive.parse(document);
			if (mk.Q(form) == null)
				mk.w("Formulário não encontrado:", form);
			// Buscando validador
			let validador = $.data($(form)[0], "validator");
			if (!validador) {
				mk.w("Validador inicialmente NULO. Provavelmente nenhum campo estava como requerido.", validador);
				if (!validador) {
					mk.w("Parse fail", validador);
					return true;
				}
			}
			// Ignorara os campos com classe ignore
			if (validador)
				validador.settings.ignore = ":hidden";
			// Conversor de validadores
			$.validator.unobtrusive.parse(document);
			// Buscando Unobtrusive Validador da microsoft
			let unobtrusiveValidation = $(form).data("unobtrusiveValidation");
			if (!unobtrusiveValidation)
				mk.w("Unobtrusive nulo", unobtrusiveValidation);
			// Executa validador se ele estiver presente
			var resultado = unobtrusiveValidation?.validate();
			mk.l("ModelState é Valido? " + resultado);
			resultado ? null : mk.TerremotoErros(form);
			return resultado;
		};
		// mk.mkValidaFull("#formNovo_model", CallbackFunction, { f: "#formNovo_model" });
		// Funcao Recursiva: Executa mkAindaPendente ate a resposta do HTTP retornar.
		// Parametro(formulario)        Formulario para validar
		// Parametro(fUIValidou)        Funcao a ser executada apos a validacao ser aprovada e recebida
		// Parametro(varRepassaA)       Variavel/Objeto que pode ser passada da solicitacao ate a resposta.
		static mkValidaFull = (form, fUIValidou, varRepassaA = null) => {
			mk.mkCountValidate++;
			if (mk.verificarCampos(form)) {
				let liberado = false;
				if (mk.mkAindaPendente(form)) {
					if (mk.mkCountValidate < 250) {
						mk.CarregarON();
						setTimeout(() => {
							mk.mkValidaFull(form, fUIValidou, varRepassaA);
						}, 10);
					}
					else {
						mk.CarregarOFF();
						console.error("&nbsp; Um ou mais campos do formul&aacute;rio n&atilde;o puderam ser validados por falta de resposta do servidor.");
					}
					return false;
				}
				else {
					liberado = true;
				}
				if (liberado) {
					mk.CarregarOFF();
					fUIValidou(varRepassaA);
					mk.mkCountValidate = 0;
				}
			}
			else {
				if (mk.mkCountValidate < 2) {
					//Auto reexecutar pois o parse do unobtrutive se perde de primeira
					setTimeout(() => {
						// Validacaes assincronas exigem timer
						mk.mkValidaFull(form, fUIValidou, varRepassaA);
					}, 10);
				}
				mk.CarregarOFF(); // Loop infinito
			}
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			AREA FASEADO								\\
		//___________________________________\\
		// FUNCAO PARA ATUALIZAR OS LINKS DE FASES
		static fUIFaseUpdateLinkFase = () => {
			mk.QAll("ul.mkUlFase li a").forEach((e) => {
				e.parentElement?.classList.remove("mkFaseBack");
				e.parentElement?.classList.remove("mkFaseAtivo");
				e.parentElement?.classList.remove("disabled");
				let eNumPag = Number(e.getAttribute("data-pag"));
				let bLibera = e.getAttribute("data-libera");
				if (this.mkFaseAtual > eNumPag) {
					e.parentElement?.classList.add("mkFaseBack");
				}
				if (this.mkFaseAtual == eNumPag) {
					e.parentElement?.classList.add("mkFaseAtivo");
				}
				if (bLibera == "false") {
					e.parentElement?.classList.add("disabled");
				}
			});
		};
		// FUNCAO PARA ATUALIZAR A TELINHA
		static fUIFaseUpdateView = (obj) => {
			for (var i = 1; i <= Number(mk.Q(".mkUlFase").getAttribute("data-totalfases")); i++) {
				mk.Q(".modalFase" + i).classList.add("oculto");
			}
			this.mkFaseAtual = obj["destinoFase"];
			mk.Q(".modalFase" + this.mkFaseAtual).classList.remove("oculto");
			mk.Q(".btnVoltar").classList.add("disabled");
			if (this.mkFaseAtual > 1) {
				mk.Q(".btnVoltar").classList.remove("disabled");
			}
			mk.Q(".btnAvancar").classList.remove("oculto");
			mk.Q(".btnEnviar").classList.add("oculto");
			if (this.mkFaseAtual >=
				Number(mk.Q(".mkUlFase").getAttribute("data-totalfases"))) {
				mk.Q(".btnAvancar").classList.add("oculto");
				mk.Q(".btnEnviar").classList.remove("oculto");
			}
			mk.fUIFaseUpdateLinkFase();
		};
		// (OnClick BOTAO) FUNCAO VOLTAR A FASE
		static fUIFaseVoltar = (esteForm) => {
			let obj = {
				destinoFase: this.mkFaseAtual - 1,
				form: esteForm,
			};
			mk.fUIFaseUpdateView(obj);
		};
		// (OnClick BOTAO) FUNCAO AVANCAR A FASE
		static fUIFaseAvancar = (esteForm) => {
			let obj = {
				destinoFase: this.mkFaseAtual + 1,
				form: esteForm,
			};
			mk.mkValidaFull(obj.form, mk.fUIFaseLiberarView, obj);
		};
		// (OnClick BOTAO) FUNCAO LINK PARA FASE ESPECIFICA
		static fUIFaseEspecifica = (e) => {
			let obj = {
				destinoFase: Number(e.getAttribute("data-pag")),
				form: "#" + mk.getFormFrom(e).id,
			};
			if (obj.destinoFase < this.mkFaseAtual ||
				e.getAttribute("data-libera") == "true") {
				mk.mkValidaFull(obj.form, mk.fUIFaseLiberarView, obj);
			}
		};
		static fUIFaseLiberarView = (obj) => {
			this.sendObjFull = mk.mkGerarObjeto(obj["form"]);
			mk.fUIFaseUpdateView(obj);
		};
		// Metodo de controle de grupos de abas.
		static mkClicarNaAba = (este) => {
			if (este != null) {
				let estaAba = Number(este.getAttribute("data-pag"));
				let listaAbas = este.parentElement?.parentElement;
				listaAbas?.querySelectorAll("a").forEach((e) => {
					e.classList.remove("active");
				});
				este.classList.add("active");
				let totalAbas = Number(listaAbas?.getAttribute("data-mkabas"));
				for (let i = 1; i <= totalAbas; i++) {
					// Giro do 1 ao Total
					mk.QAll(".mkAba" + i).forEach((e) => {
						if (i == estaAba) {
							e.classList.remove("oculto");
						}
						else {
							e.classList.add("oculto");
						}
					});
				}
			}
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MK Molde (Template/Modelo)	\\
		//___________________________________\\
		static removerAspasDuplas = (s) => {
			if (typeof s == "string") {
				s = s.replaceAll('"', "&quot;");
			}
			return s;
		};
		// Retorna o valor do chave informada, podendo ser obj.obj.chave
		// mk.getV("a.b.c",{a:{b:{c:"d"}}})
		static getV = (keys, objeto) => {
			if (typeof objeto == "object") {
				if (typeof keys == "string") {
					if (keys.includes(".")) {
						// Multi
						let ks = keys.split(".");
						let lastObj = objeto;
						let lastV = {};
						// Iterar o Keys, Ver Obj atual e Setar Conteudo;
						ks.forEach((k) => {
							lastV = lastObj[k];
							if (typeof lastV == "object") {
								lastObj = lastV;
							}
						});
						return lastV;
					}
					else {
						// Simples
						return objeto[keys];
					}
				}
				else {
					mk.w("As chaves precisam estar em formato string (" + typeof keys + ")");
				}
			}
			else {
				mk.w("Para ver a chave, o parametro objeto precisa receber um objeto. (" +
					typeof objeto +
					")");
			}
			return null;
		};
		// Conversor de "${obj.key}" em valor.
		static mkToValue = (mk, o) => {
			let ret = "";
			if (mk.indexOf("${") >= 0) {
				let ini = mk.split("${");
				ret = ini[0];
				for (let i in ini) {
					if (i == "0")
						continue;
					let end = ini[i].indexOf("}");
					let key = ini[i].slice(0, end);
					if (typeof o == "object" && o != null) {
						let v = this.removerAspasDuplas(this.getV(key, o));
						if (v != null) {
							ret += v;
						}
					}
					ret += ini[i].slice(end + 1);
				}
			}
			else {
				ret = mk;
			}
			return ret;
		};
		static mkMoldeOA = async (dadosOA, modelo = "#modelo", repositorio = ".tableListagem .listBody") => {
			return new Promise((r) => {
				let eModelo = mk.Q(modelo);
				if (eModelo == null) {
					console.error("Modelo (Template) informado (" + modelo + ") não encontrado.");
					return r(null);
				}
				let eRepositorio = mk.Q(repositorio);
				if (eRepositorio == null) {
					console.error("Repositório informado (" + repositorio + ") não encontrado.");
					return r(null);
				}
				let listaNode = "";
				let mkMoldeOAA_Execute = (o) => {
					let node = eModelo.innerHTML;
					node = mk.mkToValue(node, o);
					listaNode += node;
				};
				mk.mkExecutaNoObj(dadosOA, mkMoldeOAA_Execute);
				//Allow Tags
				listaNode = listaNode.replaceAll("&lt;", "<");
				listaNode = listaNode.replaceAll("&gt;", ">");
				eRepositorio.innerHTML = listaNode;
				r(this); // class mk
			});
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MK Include									\\
		//___________________________________\\
		static mkInclude = async () => {
			return new Promise((r) => {
				mk.QAll("body *").forEach(async (e) => {
					let destino = e.getAttribute("mkInclude");
					if (destino != null) {
						//mk.l("Incluindo: " + destino);
						let p = await mk.get.html({ url: destino, quiet: true });
						if (p.retorno != null) {
							e.innerHTML = p.retorno;
							//mk.mkNodeToScript(mk.Q(".conteudo"));
						}
						else {
							mk.l("Falhou ao coletar dados");
						}
						r(p.retorno);
					}
				});
			});
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MK UI Confirmar							\\
		//___________________________________\\
		// p { corSim: "bVerde", corNao: "bCinza"}
		static mkConfirma = async (texto = "Você tem certeza?", p = null) => {
			let possiveisBotoes = ["bCinza", "bVermelho", "bVerde"];
			let corSim = "bVerde";
			if (p?.corSim != undefined)
				corSim = p.corSim;
			let corNao = "bCinza";
			if (p?.corNao != undefined)
				corNao = p.corNao;
			let classContainer = "";
			if (p?.classContainer != undefined)
				classContainer = p.classContainer;
			return new Promise((r) => {
				function verficiarResposta() {
					let resposta = null;
					if (mk.Q(".mkConfirmadorBloco .mkConfirmadorArea .bBotao.icoSim.true"))
						resposta = true;
					if (mk.Q(".mkConfirmadorBloco .mkConfirmadorArea .bBotao.icoNao.true"))
						resposta = false;
					//mk.l("Resposta: " + resposta);
					if (resposta !== null) {
						mk.Q(".mkConfirmadorBloco .icoSim").classList.remove("true");
						mk.Q(".mkConfirmadorBloco .icoNao").classList.remove("true");
						mk.Q(".mkConfirmadorBloco").classList.add("oculto");
						retornar(resposta);
					}
				}
				let eConfirmar = Array.from(mk.Q("body").children).find((e) => e.classList.contains("mkConfirmadorBloco"));
				if (!eConfirmar) {
					let divMkConfirmarBloco = document.createElement("div");
					let divMkConfirmarFora = document.createElement("div");
					let divMkConfirmarArea = document.createElement("div");
					let divMkConfirmarTitulo = document.createElement("div");
					let divMkConfirmarTexto = document.createElement("div");
					let divMkConfirmarBotoes = document.createElement("div");
					let divMkConfirmarSim = document.createElement("button");
					let divMkConfirmarNao = document.createElement("button");
					divMkConfirmarBloco.className = "mkConfirmadorBloco microPos5";
					divMkConfirmarFora.className = "mkConfirmadorFora";
					divMkConfirmarArea.className =
						"mkConfirmadorArea microPos5 tb fsb " + classContainer;
					divMkConfirmarTitulo.className = "mkConfirmadorTitulo";
					divMkConfirmarTexto.className = "mkConfirmadorTexto";
					divMkConfirmarBotoes.className = "mkConfirmadorBotoes fsb";
					divMkConfirmarSim.className = "bBotao icoSim " + corSim;
					divMkConfirmarNao.className = "bBotao icoNao " + corNao;
					divMkConfirmarTitulo.innerHTML =
						"<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M9.05.435c-.58-.58-1.52-.58-2.1 0L.436 6.95c-.58.58-.58 1.519 0 2.098l6.516 6.516c.58.58 1.519.58 2.098 0l6.516-6.516c.58-.58.58-1.519 0-2.098L9.05.435zM5.495 6.033a.237.237 0 0 1-.24-.247C5.35 4.091 6.737 3.5 8.005 3.5c1.396 0 2.672.73 2.672 2.24 0 1.08-.635 1.594-1.244 2.057-.737.559-1.01.768-1.01 1.486v.105a.25.25 0 0 1-.25.25h-.81a.25.25 0 0 1-.25-.246l-.004-.217c-.038-.927.495-1.498 1.168-1.987.59-.444.965-.736.965-1.371 0-.825-.628-1.168-1.314-1.168-.803 0-1.253.478-1.342 1.134-.018.137-.128.25-.266.25h-.825zm2.325 6.443c-.584 0-1.009-.394-1.009-.927 0-.552.425-.94 1.01-.94.609 0 1.028.388 1.028.94 0 .533-.42.927-1.029.927z'/></svg><span>Confirmação</span>";
					divMkConfirmarTexto.innerHTML = texto;
					divMkConfirmarSim.innerHTML = "Sim";
					divMkConfirmarNao.innerHTML = "Não";
					divMkConfirmarFora.setAttribute("onclick", "mk.w('Essa funcionalidade não está disponível no momento.')");
					divMkConfirmarSim.setAttribute("onclick", "this.classList.add(true);");
					divMkConfirmarNao.setAttribute("onclick", "this.classList.add(true);");
					mk.Q("body").appendChild(divMkConfirmarBloco);
					divMkConfirmarBloco.appendChild(divMkConfirmarFora);
					divMkConfirmarBloco.appendChild(divMkConfirmarArea);
					divMkConfirmarArea.appendChild(divMkConfirmarTitulo);
					divMkConfirmarArea.appendChild(divMkConfirmarTexto);
					divMkConfirmarArea.appendChild(divMkConfirmarBotoes);
					divMkConfirmarBotoes.appendChild(divMkConfirmarSim);
					divMkConfirmarBotoes.appendChild(divMkConfirmarNao);
				}
				else {
					// Limpeza de cores anteriores
					possiveisBotoes.forEach((s) => {
						mk.QAll(".mkConfirmadorBloco .bBotao").forEach((botao) => {
							botao.classList.remove(s);
						});
					});
					// Set das cores novas
					mk.Q(".mkConfirmadorBloco .bBotao.icoSim").classList.add(corSim);
					mk.Q(".mkConfirmadorBloco .bBotao.icoNao").classList.add(corNao);
					mk.Q(".mkConfirmadorBloco").classList.remove("oculto");
					mk.Q(".mkConfirmadorTexto").innerHTML = texto;
				}
				const checkResposta = setInterval(verficiarResposta, 100);
				// Função de conclusão.
				function retornar(resultado = false) {
					clearInterval(checkResposta);
					return r(resultado);
				}
			});
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MK Botao Imagem (mkBot)			\\
		//___________________________________\\
		// Botao incluido uma imagem/pdf visualizavel e clicavel.
		// Valor inicial no value, quando não presente, exibe data-value.	
		static elementoDuranteUpload;
		static mkBotCheck = async () => {
			mk.QAll("button.mkBot").forEach(async (e) => {
				// Apenas quando contem Atualizar
				let semEvento = e.classList.contains("atualizarSemEvento");
				if (e.classList.contains("atualizar") || semEvento) {
					e.classList.remove("atualizar");
					e.classList.remove("atualizarSemEvento");
					e.classList.add("atualizando");
					// - Remove conteudo
					e.innerHTML = "";
					// - Coleta value do campo (ex: botao tem value="/img/teste.jpg")
					let v = e.getAttribute("value");
					// - Caso Nulo, Tentar pelo dataset
					if (v == null || v == "") {
						v = e.dataset.value;
					}
					let clicavel = e.dataset.clicavel;
					let exibirbarra = e.dataset.exibirbarra;
					if (v != null && v != "") {
						let tipo = null;
						let terminacao = v.slice(v.length - 3, v.length).toString().toLowerCase();
						// Verificar aqui se trata-se de um link ou de uma base64 direto no elemento.					
						// - Verifica se terminacao do arquivo é PDF ou OUTRO,
						if ((v.includes("application/pdf")) || (terminacao == "pdf")) {
							tipo = "pdf";
						}
						// << Inicio do conteúdo
						let retornar = "<";
						// FORMATOS DE ARQUIVO
						if (tipo == "pdf") {
							retornar += "embed type='application/pdf' class='mkCem mkBotEmbed' src='" + v;
						}
						else {
							retornar +=
								e.innerHTML = "img class='mkCem' src='" + v;
						}
						if (exibirbarra) {
							retornar += "#toolbar=0";
						}
						// << Fim o conteúdo
						retornar += "'>";
						// Se é ou não clicavel
						if (!clicavel) {
							retornar += "<div class='mkBotSobre'></div>";
						}
						// Set
						e.innerHTML = retornar;
						// Ao concluir, tenta executar atributo onchange, se houver
						if (!semEvento) {
							if (e.onchange) {
								e.onchange();
							}
						}
					}
					else {
						mk.w("Elemento com 'value' nulo. Esperava-se conteudo: ", v);
					}
					e.classList.remove("atualizando");
				}
			});
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MK Recomendador (mkRec)			\\
		//___________________________________\\
		static mkRecRenderizar = async () => {
			mk.QAll("input.mkRec").forEach(async (e) => {
				// Gerar Elemento de recomendações
				if (!e.nextElementSibling?.classList.contains("mkRecList")) {
					let ePai = e.parentElement;
					let ePos = Array.from(ePai?.children).indexOf(e);
					let divMkRecList = document.createElement("div");
					divMkRecList.className = "mkRecList emFoco";
					divMkRecList.setAttribute("tabindex", "-1");
					ePai?.insertBefore(divMkRecList, ePai?.children[ePos + 1]);
					e.setAttribute("oninput", "mk.mkRecUpdate(this)");
					e.setAttribute("onfocus", "mk.mkRecFoco(this,true)");
					e.setAttribute("onblur", "mk.mkRecFoco(this,false)");
					e.setAttribute("autocomplete", "off");
					const popperInstance = Popper.createPopper(e, divMkRecList, {
						placement: "bottom-start",
						strategy: "fixed",
						modifiers: [],
					});
					mk.poppers.push(popperInstance);
					mk.mkRecUpdate(e);
				}
				else {
					if (!e.getAttribute("data-selarray") && e.getAttribute("data-refill")) {
						//await mk.mkRecDelRefillProcesso(e as HTMLElement);
					}
					let geraEvento = false;
					if (e.classList.contains("atualizar"))
						geraEvento = true;
					// Atualiza a lista com base na classe "atualizar" (Gera Evento input e change)
					if (e.classList.contains("atualizar") || e.classList.contains("atualizarSemEvento")) {
						e.classList.remove("atualizar");
						e.classList.remove("atualizarSemEvento");
						e.classList.add("atualizando");
						mk.mkRecUpdate(e);
						e.classList.remove("atualizando");
					}
					if (geraEvento) {
						// Executa evento, em todos atualizar.
						// O evento serve para que ao trocar o 1, o 2 execute input para então o 3 tb ter como saber que é pra atualizar
						e.dispatchEvent(new Event("input"));
						e.dispatchEvent(new Event("change"));
					}
				}
			});
		};
		static mkRecUpdate = (e) => {
			// Recebe o elemento input principal.
			// GERA CADA ITEM DA LISTA COM BASE NO JSON
			if (e?.getAttribute("data-selarray") != "") {
				let eList = e.nextElementSibling;
				let array = e.dataset.selarray;
				eList.innerHTML = "";
				if (mk.isJson(array)) {
					let kvList = JSON.parse(array);
					let c = 0;
					/* ITENS */
					kvList.forEach((o) => {
						if (o.v != null && o.v != "") {
							if (mk.like(e.value, o.v) && e.value.trim() != o.v.trim()) {
								c++;
								let item = document.createElement("div");
								let itemTexto = document.createElement("span");
								item.className = "recItem";
								item.setAttribute("data-k", o.k);
								item.setAttribute("onmousedown", "mk.mkRecChange(this,'" + o.v + "')");
								itemTexto.innerHTML = o.v;
								item.appendChild(itemTexto);
								eList.appendChild(item);
							}
						}
					});
					if (c <= 0) {
						eList.innerHTML = "Sem recomendações";
					}
				}
				else {
					mk.w("mkRecUpdate(e):  atributo selarray Não é um JSON válido: ", array);
				}
			}
			else {
				mk.w("mkRecUpdate(e): Elemento não encontrado ou selarray dele está vazia.", e);
			}
		};
		static mkRecChange = (recItem, texto) => {
			let e = recItem?.parentElement?.previousElementSibling;
			if (e) {
				e.value = texto;
				setTimeout(() => { mk.mkRecUpdate(e); e.focus(); }, 10);
			}
			else {
				mk.w("Não foi possível alterar o elemento: ", e);
			}
		};
		static mkRecFoco = (input, f) => {
			let e = input?.nextElementSibling;
			if (e) {
				if (!f) {
					e.classList.add("emFoco");
				}
				else {
					e.classList.remove("emFoco");
				}
			}
			else {
				mk.w("Não foi possível alterar o elemento: ", e);
			}
		};
		//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
		//			MK Seletor (mkSel)					\\
		//___________________________________\\
		static poppers = [];
		/* CRIA O DROPDOWN por FOCUS */
		static mkSelRenderizar = async () => {
			mk.QAll("input.mkSel").forEach(async (e) => {
				// Transforma elemento se ele ainda não foi transformado
				if (!e.parentElement?.classList.contains("mkSelBloco")) {
					// COLETA
					let ePai = e.parentElement;
					let ePos = Array.from(ePai?.children).indexOf(e);
					// ELEMENTO no BLOCO
					let divMkSeletorBloco = document.createElement("div");
					let divMkSeletorPesquisa = document.createElement("div");
					let divMkSeletorInputExibe = document.createElement("input");
					let divMkSeletorInputExibeArrow = document.createElement("div");
					let divMkSeletorList = document.createElement("div");
					// Nomeando Classes
					divMkSeletorBloco.className = "mkSelBloco";
					divMkSeletorPesquisa.className = "mkSelPesquisa";
					divMkSeletorInputExibe.className = "mkSelInputExibe";
					divMkSeletorInputExibeArrow.className = "mkSelInputExibeArrow";
					divMkSeletorList.className = "mkSelList";
					// ORDEM no DOM
					ePai?.insertBefore(divMkSeletorBloco, ePai?.children[ePos]);
					divMkSeletorBloco.appendChild(e);
					divMkSeletorBloco.appendChild(divMkSeletorPesquisa);
					divMkSeletorBloco.appendChild(divMkSeletorList);
					divMkSeletorPesquisa.appendChild(divMkSeletorInputExibe);
					divMkSeletorPesquisa.appendChild(divMkSeletorInputExibeArrow);
					// Transfere style
					divMkSeletorBloco.setAttribute("style", e.getAttribute("style") ?? "");
					// Flexas que movem o selecionado quando há apenas 1 possibilidade de selecao.
					if (e.getAttribute("data-selmovesel") == "true" &&
						e.getAttribute("data-selapenas") == "1") {
						let divMkSelArrowSelLeft = document.createElement("div");
						let divMkSelArrowSelRight = document.createElement("div");
						divMkSelArrowSelLeft.className = "mkSelArrowSelLeft microPos6";
						divMkSelArrowSelRight.className = "mkSelArrowSelRight microPos4";
						divMkSeletorPesquisa.appendChild(divMkSelArrowSelLeft);
						divMkSeletorPesquisa.appendChild(divMkSelArrowSelRight);
						divMkSelArrowSelLeft.setAttribute("onclick", "mk.mkSelLeftSel(this)");
						divMkSelArrowSelRight.setAttribute("onclick", "mk.mkSelRightSel(this)");
						divMkSeletorBloco.style.setProperty("--mkSelArrowSize", "24px");
					}
					// Seta atributos e Gatilhos
					e.removeAttribute("style");
					e.setAttribute("readonly", "true");
					e.setAttribute("tabindex", "-1");
					mk.mkSelTabIndex(e);
					divMkSeletorInputExibe.setAttribute("placeholder", "Filtro \u{1F50D}");
					divMkSeletorInputExibe.setAttribute("onfocus", "mk.mkSelPesquisaFocus(this)");
					divMkSeletorInputExibe.setAttribute("onblur", "mk.mkSelPesquisaBlur(this)");
					divMkSeletorInputExibe.setAttribute("oninput", "mk.mkSelPesquisaInput(this)");
					divMkSeletorInputExibe.setAttribute("onkeydown", "mk.mkSelPesquisaKeyDown(event)");
					divMkSeletorInputExibe.setAttribute("autocomplete", "off");
					divMkSeletorList.addEventListener("scroll", (ev) => {
						mk.mkSelMoveu(ev.target);
					});
					// Popular Lista
					mk.mkSelPopularLista(e);
					// Seleciona baseado no value do input
					mk.mkSelUpdate(e);
					// Deixar Elemento de forma visivel, mas inacessivel.
					if (e.getAttribute("data-dev") != "true") {
						e.classList.add("mkSecreto");
					}
					// v2
					const popperInstance = Popper.createPopper(divMkSeletorPesquisa, divMkSeletorList, {
						placement: "bottom-start",
						strategy: "fixed",
						modifiers: [],
					});
					mk.poppers.push(popperInstance);
				}
				else {
					// Se não tem array, mas tem o refill e entrou para atualizar, faz o processo de refill genérico
					if (!e.getAttribute("data-selarray") && e.getAttribute("data-refill")) {
						await mk.mkSelDelRefillProcesso(e);
					}
					// Atualiza a lista com base na classe "atualizar" (Gera Evento input e change)
					if (e.classList.contains("atualizar")) {
						e.classList.remove("atualizar");
						e.classList.add("atualizando");
						mk.mkSelPopularLista(e);
						mk.mkSelUpdate(e);
						// Executa evento, em todos atualizar.
						// O evento serve para que ao trocar o 1, o 2 execute input para então o 3 tb ter como saber que é pra atualizar
						e.dispatchEvent(new Event("input"));
						e.dispatchEvent(new Event("change"));
						e.classList.remove("atualizando");
					}
					if (e.classList.contains("atualizarSemEvento")) {
						e.classList.remove("atualizarSemEvento");
						e.classList.add("atualizando");
						mk.mkSelPopularLista(e);
						mk.mkSelUpdate(e);
						e.classList.remove("atualizando");
					}
					// Manter index em -1 para não chegar até esse campo
					e.setAttribute("tabindex", "-1");
					mk.mkSelTabIndex(e);
					//mk.mkSelReposicionar(e.parentElement.children[2]);
				}
			});
			// Atualiza posição com a mesma frequencia que pesquisa os elementos.
			mk.poppers.forEach((o) => {
				o.update();
			});
		};
		static mkSelDelRefillProcesso = async (eName, cod = null) => {
			return new Promise(async (r) => {
				let e = mk.Q(eName);
				if (e) {
					let url = appPath + e.getAttribute("data-refill");
					cod != null ? (url += cod) : null;
					let p = await mk.get.json(url);
					if (p.retorno != null) {
						let kv = p.retorno;
						if (typeof p.retorno == "object") {
							kv = JSON.stringify(p.retorno);
						}
						if (mk.isJson(kv)) {
							e.setAttribute("data-selarray", kv);
							r(e);
						}
						else {
							console.error("Resultado não é um JSON. (mkSelDlRefill)");
						}
					}
				}
				else {
					mk.w("Função (mkSelDlRefill) solicitou Refill em um campo inexistente (JS)");
				}
			});
		};
		static mkSelDlRefill = async (eName, cod, clear = true) => {
			mk.mkSelDelRefillProcesso(eName, cod).then((e) => {
				if (clear)
					e.value = "";
				e.classList.add("atualizar");
			});
		};
		// Quando desativado, precisa desativar o TAB também
		static mkSelTabIndex = (e) => {
			if (e.classList.contains("disabled")) {
				let pes = e.nextElementSibling;
				if (pes) {
					if (pes.classList.contains("mkSelPesquisa")) {
						pes.firstElementChild?.setAttribute("tabindex", "-1");
					}
				}
			}
			else {
				let pes = e.nextElementSibling;
				if (pes) {
					if (pes.classList.contains("mkSelPesquisa")) {
						pes.firstElementChild?.removeAttribute("tabindex");
					}
				}
			}
		};
		/* Ao Tentar Selecionar um novo item */
		static mkSelSelecionar = (eItem) => {
			let ePrincipal = eItem.parentElement?.parentElement?.firstElementChild;
			let KV = mk.mkSelGetKV(ePrincipal);
			// Obtem limite de seleções
			let selapenas = ePrincipal?.getAttribute("data-selapenas") || 1;
			let selLimit = Number(selapenas);
			// QUANDO O LIMITE é 1
			if (selLimit == 1) {
				// Muda valor do input pelo clicado e Gera o evento
				ePrincipal.value = eItem.getAttribute("data-k");
				ePrincipal?.dispatchEvent(new Event("input"));
				// Transfere valor para o Display (Exibe)
				(eItem?.parentElement?.previousElementSibling?.firstElementChild).value =
					eItem.innerHTML;
			}
			else if (selLimit > 1 || selLimit < 0) {
				let itemK = eItem.getAttribute("data-k");
				let jaSelecionado = 0;
				// Forma um array caso ainda não seja, pois pode seleconar mais de um.
				let arraySelecionado = [];
				// Verifica se algum KV.k é o K clicado. (Para saber se vai adicionar ou remover)
				KV.forEach((ObjKV) => {
					arraySelecionado.push(ObjKV.k.toString());
					if (ObjKV.k == itemK)
						jaSelecionado++;
				});
				if (jaSelecionado > 0) {
					// Remove valor da lista selecionada
					arraySelecionado.splice(arraySelecionado.indexOf(itemK), 1);
				}
				else {
					// Verifica se é possivel selecionar mais (Se estiver negativo, pode selecionar infinito)
					if (arraySelecionado.length < selLimit || selLimit < 0) {
						// Acrescenta valor
						arraySelecionado.push(itemK);
					}
				}
				// Limpar seleções vazias
				arraySelecionado.forEach((item) => {
					if (item == "") {
						arraySelecionado.splice(arraySelecionado.indexOf(item), 1);
					}
				});
				// Quando estiver vazio, reseta o campo.
				// Seta o valor no campo de input
				if (arraySelecionado.length == 0) {
					ePrincipal.value = ePrincipal.defaultValue;
				}
				else {
					let string = JSON.stringify(arraySelecionado);
					if (ePrincipal.type == "text")
						ePrincipal.value = string;
					else
						console.error("Erro durante o Set/Conversão do campo. É necessário que este campo seja tipo string.");
				}
				// Gera o Evento
				ePrincipal.dispatchEvent(new Event("input"));
				// Mantem foco no Display, pois pode selecionar mais de um
				setTimeout(() => {
					eItem.parentElement.previousElementSibling.firstElementChild.focus();
				}, 1);
			}
			mk.mkSelUpdate(ePrincipal);
			// Evento change apos terminar a atualizacao
			ePrincipal.dispatchEvent(new Event("change"));
		};
		// Selecionar o anterior ao atual
		static mkSelLeftSel = (e) => {
			let eAlvo = null;
			Array.from(e.parentElement?.nextElementSibling?.children).forEach((el) => {
				if (el.getAttribute("data-s") == "1") {
					eAlvo = el.previousElementSibling;
					return;
				}
			});
			if (eAlvo == null) {
				mk.mkSelSelecionar(e.parentElement?.nextElementSibling?.lastElementChild);
			}
			else {
				if (eAlvo.classList.contains("mkSelItemDeCima")) {
					eAlvo = eAlvo.parentElement?.lastElementChild
						?.previousElementSibling;
				}
				mk.mkSelSelecionar(eAlvo);
			}
		};
		// Selecionar o próximo ao atual
		static mkSelRightSel = (e) => {
			let eAlvo = null;
			Array.from(e.parentElement.nextElementSibling.children).forEach((el) => {
				if (el.getAttribute("data-s") == "1") {
					eAlvo = el.nextElementSibling;
					return;
				}
			});
			if (eAlvo == null) {
				mk.mkSelSelecionar(e.parentElement.nextElementSibling.firstElementChild);
			}
			else {
				if (eAlvo.classList.contains("mkSelItemDeBaixo")) {
					eAlvo = eAlvo.parentElement?.firstElementChild
						?.nextElementSibling;
				}
				mk.mkSelSelecionar(eAlvo);
			}
		};
		static mkSelPopularLista = (e) => {
			// GERA CADA ITEM DA LISTA COM BASE NO JSON
			if (e.getAttribute("data-selarray") != "") {
				let eList = e.nextElementSibling.nextElementSibling;
				eList.innerHTML = "";
				try {
					let seletorArray = JSON.parse(e.getAttribute("data-selarray"));
					if (seletorArray != null) {
						let c = 0;
						/* ITENS */
						seletorArray.forEach((o) => {
							if (o.k != null) {
								c++;
								let divMkSeletorItem = document.createElement("div");
								let divMkSeletorItemTexto = document.createElement("span");
								let divMkSeletorItemArrow = document.createElement("div");
								divMkSeletorItem.className = "mkSelItem";
								divMkSeletorItemArrow.className = "mkSelItemArrow";
								divMkSeletorItem.setAttribute("data-k", o.k);
								divMkSeletorItem.setAttribute("onmousedown", "mk.mkSelSelecionar(this)");
								divMkSeletorItemTexto.innerHTML = o.v;
								divMkSeletorItem.appendChild(divMkSeletorItemTexto);
								divMkSeletorItem.appendChild(divMkSeletorItemArrow);
								eList.appendChild(divMkSeletorItem);
							}
						});
						if (c <= 0) {
							eList.innerHTML = "Nenhuma opção";
						}
						else if (c > 10) {
							if (e.getAttribute("data-selmove") != "false") {
								let divMkSelCima = document.createElement("div");
								divMkSelCima.className = "mkSelItemDeCima microPos2";
								divMkSelCima.setAttribute("onmousemove", "mk.mkSelMoveCima(this);");
								divMkSelCima.innerHTML = "↑ ↑ ↑";
								eList.insertBefore(divMkSelCima, eList.firstElementChild);
								let divMkSelBaixo = document.createElement("div");
								divMkSelBaixo.className = "mkSelItemDeBaixo microPos8";
								divMkSelBaixo.setAttribute("onmousemove", "mk.mkSelMoveBaixo(this);");
								divMkSelBaixo.innerHTML = "↓ ↓ ↓";
								eList.appendChild(divMkSelBaixo);
							}
						}
					}
				}
				catch {
					console.error("Erro durante conversao para Json:" + e.getAttribute("data-selarray"));
				}
			}
		};
		/* EVENTO de Pesquisa (FOCUS) */
		static mkSelPesquisaFocus = (e) => {
			// Atualiza Itens Selecionados, caso houve mudança sem atualizar.
			mk.mkSelUpdate(e.parentElement.previousElementSibling);
			// Limpa o Display
			e.value = "";
			// Limpa o resultado do filtro anterior
			let eList = e.parentElement.nextElementSibling;
			let ePrimeiroSel = null;
			Array.from(eList.children).forEach((el) => {
				el.style.display = "";
				el.removeAttribute("data-m");
				if (el.getAttribute("data-s") == 1 && ePrimeiroSel == null)
					ePrimeiroSel = el;
			});
			// Faz movimento no scroll até o primeiro item selecionado
			let primeiroOffSet = ePrimeiroSel?.offsetTop || 0;
			eList.scrollTop =
				primeiroOffSet - 120 - (eList.offsetHeight - eList.clientHeight) / 2;
			// Atualizar posição da Lista.
			mk.mkSelReposicionar(e.parentElement.nextElementSibling);
		};
		static getParentScrollTop = (e) => {
			let eHtml = e;
			let soma = 0;
			while (eHtml.tagName != "HTML") {
				soma += eHtml.scrollTop;
				eHtml = eHtml.parentElement;
			}
			return soma;
		};
		static mkSelReposicionar = (eList) => {
			// Redimenciona a lista do tamanho do campo pesquisar
			let ew = eList.previousElementSibling.offsetWidth;
			eList.style.minWidth = ew + "px";
			eList.style.maxWidth = ew + "px";
			/* Substituido pelo Poper
			// Posiciona a lista.
			// Lado esquerdo baseado na posicao, mas em mobile fica full.
			let wLargura = window.innerWidth;
			if (wLargura < 768) {
					eList.style.top = 35 + "px";
					eList.style.left = 35 + "px";
			} else {
					// Primeiramente seta a posição ref ao input fixo.
					eList.style.top =
							eRef.offsetTop -
							mk.getParentScrollTop(eRef) +
							eRef.offsetHeight +
							2 +
							"px";

					eList.style.left = eRef.offsetLeft + "px";
					// Depois, verifica se saiu da tela
					let posXCantoOpostoRef = eRef.offsetLeft + eRef.offsetWidth;
					let posXCantoOpostoList = eList.offsetLeft + eList.offsetWidth;
					if (posXCantoOpostoList > (mk.Q("body") as HTMLElement).offsetWidth) {
							eList.style.left = posXCantoOpostoRef - eList.offsetWidth - 1 + "px";
					}
			}
	*/
		};
		/* EVENTO de Pesquisa (BLUR) */
		static mkSelPesquisaBlur = (e) => {
			mk.mkSelUpdate(e.parentElement.previousElementSibling);
		};
		/* EVENTO de Pesquisa (KEYDOWN) */
		static mkSelPesquisaKeyDown = (ev) => {
			let isNegado = false;
			//mk.l(ev);
			if (ev.key == "Escape") {
				ev.srcElement.blur();
			}
			if (ev.key == "ArrowUp" || ev.key == "ArrowDown" || ev.key == "Enter") {
				isNegado = true;
				let eList = ev.srcElement.parentElement.nextElementSibling;
				let eListItem;
				let array = Array.from(eList.children).filter((e) => {
					return e.style.display != "none";
				});
				let eM = array.find((e) => e.getAttribute("data-m") == "1");
				Array.from(eList.children).forEach((e) => e.removeAttribute("data-m"));
				if (ev.key == "Enter") {
					if (eM)
						mk.mkSelSelecionar(eM);
					ev.srcElement.blur();
				}
				if (ev.key == "ArrowUp") {
					isNegado = true;
					let ultimo = array[array.length - 1];
					let peNultimo = array[array.length - 2];
					if (eM) {
						let indexProximo = array.indexOf(eM) - 1;
						if (array[indexProximo] &&
							!array[indexProximo].classList.contains("mkSelItemDeCima")) {
							eListItem = array[indexProximo];
						}
						else {
							if (ultimo?.classList.contains("mkSelItemDeBaixo")) {
								eListItem = peNultimo;
							}
							else {
								eListItem = ultimo;
							}
						}
					}
					else {
						if (ultimo?.classList.contains("mkSelItemDeBaixo")) {
							eListItem = peNultimo;
						}
						else {
							eListItem = ultimo;
						}
					}
					eListItem?.setAttribute("data-m", "1");
					let alvoOffsetTop = eListItem?.offsetTop || 0;
					eList.scrollTop =
						alvoOffsetTop - 120 - (eList.offsetHeight - eList.clientHeight) / 2;
				}
				if (ev.key == "ArrowDown") {
					isNegado = true;
					if (eM) {
						let indexProximo = array.indexOf(eM) + 1;
						if (array[indexProximo] &&
							!array[indexProximo].classList.contains("mkSelItemDeBaixo")) {
							eListItem = array[indexProximo];
						}
						else {
							if (array[0]?.classList.contains("mkSelItemDeCima")) {
								eListItem = array[1];
							}
							else {
								eListItem = array[0];
							}
						}
					}
					else {
						if (array[0]?.classList.contains("mkSelItemDeCima")) {
							eListItem = array[1];
						}
						else {
							eListItem = array[0];
						}
					}
					eListItem?.setAttribute("data-m", "1");
					let alvoOffsetTop = eListItem?.offsetTop || 0;
					eList.scrollTop =
						alvoOffsetTop - 120 - (eList.clientHeight - eList.offsetHeight) / 2;
					// console.table({
					// 	Resultado: eList.scrollTop,
					// 	eListItem: eListItem.offsetTop,
					// 	eListOffsetTop (120): eList.offsetTop,
					// 	eListOffSetHeight: eList.offsetHeight,
					// 	eListClientHeight: eList.clientHeight,
					// });
				}
			}
			if (isNegado) {
				ev.preventDefault();
			}
		};
		/* EVENTO de Pesquisa (INPUT) */
		static mkSelPesquisaInput = (e) => {
			let cVisivel = 0;
			let eList = e.parentElement.nextElementSibling;
			Array.from(eList.children).forEach((el) => {
				let exibe = false;
				if (el.classList.contains("mkSelItem")) {
					let strInputado = e.value.toLowerCase();
					let strFromKv = el.firstElementChild.innerHTML.toLowerCase();
					if (mk.like(strInputado, strFromKv)) {
						exibe = true;
						cVisivel++;
					}
				}
				if (exibe) {
					el.style.display = "";
				}
				else {
					el.style.display = "none";
				}
			});
			if (cVisivel > 10) {
				eList.firstElementChild.style.display = "";
				eList.lastElementChild.style.display = "";
			}
		};
		// Receber e = div .mkSelList
		static mkSelMoveu = (e) => {
			if (e.firstElementChild.classList.contains("mkSelItemDeCima")) {
				// if (e.scrollTop == 0) {
				// 	e.firstElementChild.style.display = "none";
				// 	e.lastElementChild.style.display = "";
				// } else if (e.scrollTop + e.clientHeight >= e.scrollHeight) {
				// 	e.firstElementChild.style.display = "";
				// 	e.lastElementChild.style.display = "none";
				// } else {
				e.firstElementChild.style.display = "";
				e.lastElementChild.style.display = "";
				// }
			}
		};
		// Receber e = div .mkSelItemDeCima
		static mkSelMoveCima = (e) => {
			let eList = e.parentElement;
			eList.scrollTop = eList.scrollTop - 5;
			mk.mkSelMoveu(eList);
		};
		// Receber e = div .mkSelItemDeBaixo
		static mkSelMoveBaixo = (e) => {
			let eList = e.parentElement;
			eList.scrollTop = eList.scrollTop + 5;
			mk.mkSelMoveu(eList);
		};
		/* ATUALIZA Display e Selecionados*/
		static mkSelUpdate = (e, KV = null) => {
			if (KV == null) {
				KV = mk.mkSelGetKV(e);
			}
			// Desmarcar todos mkSelItem pra 0
			Array.from(e.nextElementSibling.nextElementSibling.children).forEach((el) => {
				el.setAttribute("data-s", "0");
			});
			KV.forEach((o) => {
				/* Marcar mkSelItem pra 1 onde tem K selecionado */
				Array.from(e.nextElementSibling.nextElementSibling.children).forEach((item) => {
					if (item.getAttribute("data-k") == o.k) {
						item.setAttribute("data-s", "1");
					}
				});
			});
			// Seta Valor do display
			mk.mkSelSetDisplay(e, KV);
		};
		// SET a ARRAY do SELETOR, formato MAP (Recebe array de arrays)
		static mkSelArraySetMap = (e, map) => {
			if (e) {
				if (map instanceof Map) {
					let kv = [];
					for (let [k, v] of map) {
						kv.push({
							k: k,
							v: v,
						});
					}
					mk.mkSelArraySetKV(e, kv);
				}
				else {
					mk.w("Função mkSelArraySetMap() precisa receber um objeto formato Map no segundo parametro");
				}
				return e;
			}
			else {
				mk.w("Função mkSelArraySetMap() precisa receber o elemento no primeiro parametro");
				return null;
			}
		};
		// SET a ARRAY do SELETOR, formato KV (Recebe uma array de objetos)
		static mkSelArraySetKV = (e, kv) => {
			let kvj = JSON.stringify(kv);
			e.dataset.selarray = kvj;
			e.classList.add("atualizarSemEvento");
			return e;
		};
		// GET do ARRAY do SELETOR, formato MAP
		static mkSelArrayGetMap = (e) => {
			let kvs = e.dataset.selarray;
			let map = [];
			if (mk.isJson(kvs)) {
				let kv = JSON.parse(kvs);
				kv.forEach((o) => {
					map.push([o.k, o.v]);
				});
			}
			return new Map(map);
		};
		// GET do ARRAY do SELETOR, formato KV
		static mkSelArrayGetKV = (e) => {
			let kv = e.dataset.selarray;
			if (mk.isJson(kv)) {
				kv = JSON.parse(kv);
			}
			return kv;
		};
		// GET do ATUAL SELECIONADO do SELETOR, formato MAP
		static mkSelGetMap = (e) => {
			let kv = mk.mkSelGetKV(e);
			let map = [];
			kv.forEach((o) => {
				map.push([o.k, o.v]);
			});
			return new Map(map);
		};
		// GET do ATUAL SELECIONADO do SELETOR, formato KV
		// Retorna o Objeto em formato KV dos itens selecionados do elemento E
		static mkSelGetKV = (e) => {
			let kSels;
			let kOpcoes;
			// Lista de Selecoes vira K do KV
			if (mk.isJson(e.value)) {
				kSels = JSON.parse(e.value);
				if (!Array.isArray(kSels)) {
					kSels = [{ k: kSels }];
				}
				else {
					kSels = [];
					JSON.parse(e.value).forEach((kSel) => {
						kSels.push({ k: kSel });
					});
				}
			}
			else
				kSels = [{ k: e.value }];
			// Prepara lista de Opções para iterar
			if (mk.isJson(e.dataset.selarray)) {
				kOpcoes = JSON.parse(e.dataset.selarray);
				if (!Array.isArray(kOpcoes)) {
					kOpcoes = [{ k: kOpcoes, v: "\u{2209} Opções" }];
				}
			}
			else
				kOpcoes = null;
			if (kOpcoes != null) {
				// Acrescentar V ao KV
				kSels.forEach((objKv) => {
					kOpcoes.forEach((opcao) => {
						if (opcao.k == objKv.k) {
							objKv.v = opcao.v;
						}
					});
				});
			}
			return kSels;
		};
		static mkSelSetDisplay = (e, KV) => {
			if (KV.length <= 0) {
				mk.w("Não foi possível encontrar os itens selecionados.");
				e.nextElementSibling.firstElementChild.value = "Opções \u{2209}";
			}
			else {
				if (KV.length == 1) {
					let display = "-- Selecione --";
					if (KV[0].v != null) {
						display = KV[0].v;
					}
					if (display == "-- Selecione --") {
						// Criado um argumento indicando que o VALOR do campo está dessincronizado com as POSSIBILIDADDES em kv.
						e.dataset.selerror = "true";
						e.dataset.selerrorMsg =
							"O item selecionado não está na lista de possibilidades";
					}
					else {
						e.dataset.selerror = "false";
						e.dataset.selerrorMsg = "";
					}
					e.nextElementSibling.firstElementChild.value = display;
				}
				else if (KV.length > 1) {
					e.nextElementSibling.firstElementChild.value =
						"[" + KV.length + "] Selecionados";
				}
			}
		};
		// IMPORTAR - Classe - Coleta o html externo
		static importar = async (tagBuscar = ".divListagemContainer") => {
			return new Promise((r) => {
				mk.QAll(tagBuscar + " *").forEach(async (e) => {
					let destino = e.getAttribute("mkImportar");
					if (destino != null) {
						let p = await mk.get.html({ url: destino, quiet: true });
						if (p.retorno != null) {
							e.removeAttribute("mkImportar");
							e.innerHTML = p.retorno;
							try {
								mk.mkNodeToScript(e);
							}
							catch (error) {
								console.group("Auto Import por TAG lancou erros:");
								console.error("ERRO: ", error);
								mk.ge();
							}
						}
						else {
							mk.l("Falhou ao coletar dados");
						}
						r(p.retorno);
					}
				});
			});
		};
	} // <<< FIM MK Class.
	//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\\
	//		AO INICIAR										\\
	//___________________________________\\
	mk.mkClicarNaAba(mk.Q(".mkAbas a.active")); // Inicia no ativo
	/* INICIALIZA e GERA TIMER de busca por novos elementos */
	//mk.mkSelRenderizar();
	setInterval(() => {
		mk.mkSelRenderizar();
		mk.mkRecRenderizar();
		mk.mkBotCheck();
		// Itera sobre todos os Poppers para atualizar na mesma frequencia deste intervalo.
		mk.poppers.forEach((o) => {
			o.update();
		});
	}, 100);

	// FIM UPDATE MKLIB
</script>

<!-- SITE JS -->
<script defer>
	let l = (...s) => {
		console.log("=>", ...s);
	};

	let icoArquivo =
		"<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16' class='icoArquivo'><path d='M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z'/></svg>";
	let = pathIcoAdd =
		"<path d='M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z'/><path d='M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z'/>";
	let = pathIcoEdit =
		"<path d='M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zm.646 6.061L9.793 2.5 3.293 9H3.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.207l6.5-6.5zm-7.468 7.468A.5.5 0 0 1 6 13.5V13h-.5a.5.5 0 0 1-.5-.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.5-.5V10h-.5a.499.499 0 0 1-.175-.032l-.179.178a.5.5 0 0 0-.11.168l-2 5a.5.5 0 0 0 .65.65l5-2a.5.5 0 0 0 .168-.11l.178-.178z'/>";

	let arq = null;

	let listas = [];
	let keys = [];
	// KVLR
	// K (Chave)	- V (Valor) - L (Label) - R (REGEX)	- T (TAG Html) - A (Attributos Tag) - I (Value no Inner)
	keys.push({ k: "mCod", v: "", l: "Id", r: "", t: "input", a: "type='text'", i: false });
	keys.push({ k: "mTit", v: "", l: "Título", r: "", t: "input", a: "type='text'", i: false });
	keys.push({ k: "mTit2", v: "", l: "SubTítulo", r: "", t: "input", a: "type='text'", i: false });
	keys.push({ k: "mDat", v: "", l: "Data", r: mk.util.data[1], t: "input", a: "type='text'", i: false });
	keys.push({ k: "mDes", v: "", l: "Descrição", r: "", t: "textarea", a: "cols='50' rows='10'", i: true });

	// FUNCOES
	const fr = (i) => {
		let f = {};
		for (let e of i) {
			f[e] ? f[e]++ : (f[e] = 1);
		}
		return Math.floor(
			Object.values(f).reduce((a, b) => {
				return (a + b) / 2;
			})
		);
	};

	const em = (i, x, s) => {
		let o = i;
		for (let c = x; c > 0; c--) {
			o = en(o, s);
		}
		return o;
	};

	const en = (i, s) => {
		let u = i.length - 1;
		let o = [];
		let c = 0;
		while (c <= u) {
			let p = (c + 1) % 4;
			if (p == 0 && c != 0) {
				s
					? o.push(...[i[c - 2], i[c], i[c - 1], i[c - 3]])
					: o.push(...[i[c], i[c - 3], i[c - 1], i[c - 2]]);
			}
			c++;
		}
		return o;
	};

	const re = (i) => {
		let c = "";
		while (!(i.length % 4 == 0)) {
			c += i[i.length - 1];
			i = i.slice(0, i.length - 1);
		}
		return [i, c];
	};

	const op = (i) => {
		let b = [];
		let a = [
			..."VnyEqWRBOUYsz2391LbGNuHgeachTjdrAioX0MwPZQkStmv4pJx78=KlDI65CFf",
		];
		let c = a.slice(60, a.length);
		b = em(a, i, 1);
		let o = [];
		for (let c = 0; c < b.length; c += 4)
			o.push(b[c + 2] + b[c + 1] + b[c + 3] + b[c]);
		o.sort().reverse();
		for (let x in o) o[x] = [...o[x]].reverse().join("");
		return [...(o.join("") + c.join(""))];
	};

	const m = (i, b, r) => {
		if (r) b = b.reverse();
		let d = b.length;
		let o = [];
		for (let x in i) {
			let c = b.indexOf(i[x]) + 1;
			if (c >= d) c = 0;
			o.push(b[c]);
		}
		return o;
	};

	const fi = (i) => {
		i = [...i];
		let r = re(i);
		let e = em(r[0], fr(i) + 1, true);
		let mo = Math.floor(Math.random() * 99);
		let b = op(mo);
		let o = m(e, b, false);
		return mo.toString().padStart(2, "0") + o.join("") + r[1];
	};

	const fo = (i) => {
		let mo = Number(i.substring(0, 2));
		let b = op(mo);
		let a = m([...i.substring(2, i.length)], b, true);
		let r = re(a);
		let e = em(r[0], fr(a) + 1, false);
		let o = [];
		for (let p = 0; p <= e.length; p++) o[p] = e[p];
		return o.join("") + r[1];
	};

	const aoExportar = () => {
		let codificado = fi(mk.encod(JSON.stringify(listas[0].dadosFull)));
		l(codificado.length);
		var a = document.createElement("a");
		var blobData = new Blob([codificado]);
		a.href = URL.createObjectURL(blobData);
		a.download = "cc" + mk.getFullData() + ".zip";
		a.click();
	};

	const aoReceberConteudo = (conteudo) => {
		listas[0] = new mk(
			conteudo,
			".divListagemContainer",
			"#modelo",
			".iConsultas",
			{
				keys: keys,
			}
		);
		mk.QverOff(".body");
		mk.QverOn(".listas");
	};

	const aoClicarCriar = () => {
		listas.push(
			new mk([], ".divListagemContainer", "#modelo", ".iConsultas", {
				keys: keys,
			})
		);
		mk.QverOff(".body");
		mk.QverOn(".listas");
	};

	const aoSair = () => {
		listas = [];
		mk.QverOn(".body");
		mk.QverOff(".listas");
	};

	const lerTexto = async (arq) => {
		return new Promise((r) => {
			let leitor = new FileReader();
			leitor.onload = () => {
				r(leitor.result);
			};
			leitor.readAsText(arq);
		});
	};

	const aoImportarDescodificado = async () => {
		l("Importar");
		mkt = mk.Q("input[name='importar']").click();
	};

	const aoAlterarInputImport = async (ev) => {
		let arqs = ev.target.files;
		l(arqs);
		if (arqs.length > 0) {
			let conteudo = await lerTexto(arqs[0]);
			splitado = conteudo.split("█");
			let dados = [];
			for (var i = 0; i < splitado.length - 1; i = i + 5) {
				dados.push({
					mCod: splitado[i],
					mTit: splitado[i + 1],
					mTit2: splitado[i + 2],
					mDat: splitado[i + 3],
					mDes: splitado[i + 4],
				});
			}
			aoReceberConteudo(dados);
		}
	};

	const aoAlterarInput = async (ev) => {
		let arqs = ev.target.files;
		l(arqs);
		if (arqs.length > 0) {
			let alvo = mk.getEClass(mk.Q(ev.target), "descarregavel").children[0];
			alvo.innerHTML = icoArquivo + arqs[0].name;
			let conteudo = await lerTexto(arqs[0]);
			let d = JSON.parse(mk.decod(fo(conteudo)));
			aoReceberConteudo(d);
		}
	};

	const aoDescarregar = async (ev) => {
		ev.preventDefault();
		let arqs = ev.dataTransfer.files; // the files that were dropped
		if (arqs.length > 0) {
			let alvo = mk.getEClass(mk.Q(ev.target), "descarregavel").children[0];
			alvo.innerHTML = icoArquivo + arqs[0].name;
			let conteudo = await lerTexto(arqs[0]);
			let d = JSON.parse(mk.decod(fo(conteudo)));
			aoReceberConteudo(d);
		}
		mk.QAll(".carga").forEach((e) => {
			e.classList.remove("carga");
		});
		mk.QAll("input[type='file']").forEach((e) => {
			e.value = "";
		});
	};

	const aoPassarCarga = (ev) => {
		ev.preventDefault();
		let eSobre = ev.toElement;
		mk.QAll(".carga").forEach((e) => {
			e.classList.remove("carga");
		});
		if (eSobre.classList.contains("descarregavel")) {
			eSobre.classList.add("carga");
		}
	};

	const aoClicarNivel2Cancelar = () => {
		mk.QverOn(".listas");
		mk.QverOff(".operacaoContainer");
	};

	const uiGetADD = async (listId) => {
		mk.QverOff(".listas");
		mk.QverOn(".operacaoContainer");
		mk.Q(".operacaoTitulo").innerHTML = "Adicionar";
		mk.Q(".operacaoAcao").innerHTML = "Adicionar";
		mk.Q(".operacaoAcaoIco").innerHTML = pathIcoAdd;
		mk.Q(".operacaoBotao").setAttribute(
			"onclick",
			"uiSetADD(" + listId + ")"
		);
		l(listas[listId].getModel());
		await mk.mkMoldeOA(
			listas[listId].getModel(),
			"#modeloOperacao",
			".operacaoCampos"
		);
		mk.QSet(
			".operacaoCampos input[name='" + listas[listId].c.pk + "']",
			listas[listId].getNewPK()
		);
	};

	const uiGetEDIT = async (tr, listId) => {
		mk.QverOff(".listas");
		mk.QverOn(".operacaoContainer");
		let k = listas[listId].c.pk;
		let v = tr.getAttribute("id");
		mk.Q(".operacaoTitulo").innerHTML = "Editar";
		mk.Q(".operacaoAcao").innerHTML = "Editar";
		mk.Q(".operacaoAcaoIco").innerHTML = pathIcoEdit;
		mk.Q(".operacaoBotao").setAttribute(
			"onclick",
			"uiSetEDIT('" + k + "','" + v + "', " + listId + ")"
		);
		let objeto = listas[listId].dadosFull.find((o) => o[k] == v);
		// l("Editando: [k:" + k + ",v:" + v + "]", objeto);
		await mk.mkMoldeOA(
			listas[listId].getKVLR(objeto),
			"#modeloOperacao",
			".operacaoCampos"
		);
	};

	const uiGetDEL = async (tr, listId) => {
		let k = listas[listId].c.pk;
		let v = tr.getAttribute("id");
		mk.mkConfirma("Você realmente quer deletar esta linha?").then((r) => {
			if (r) uiSetDEL(k, v, listId);
		});
	};

	// ACOES
	const uiSetADD = async (listId) => {
		let obj = mk.mkGerarObjeto(".operacaoCampos");
		// Método de ADICIONAR da biblioteca:
		listas[listId].add(obj);
		mk.QverOff(".operacaoContainer");
		mk.QverOn(".listas");
	};
	const uiSetEDIT = async (k, v, listId) => {
		let obj = mk.mkGerarObjeto(".operacaoCampos");
		// Método de EDITAR da biblioteca:
		listas[listId].edit(obj, k, v);
		mk.QverOff(".operacaoContainer");
		mk.QverOn(".listas");
	};
	const uiSetDEL = async (k, v, listId) => {
		// Método de DELETAR da biblioteca:
		listas[listId].del(k, v);
		mk.QverOff(".operacaoContainer");
		mk.QverOn(".listas");
	};
	const uiClearFiltro = async (listId) => {
		// Método de LIMPAR FILTRO da biblioteca:
		listas[listId].clearFiltro();
		mk.QverOff(".operacaoContainer");
		mk.QverOn(".listas");
	};
</script>

</html>
